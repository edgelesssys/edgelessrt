diff --git a/3rdparty/dlmalloc/allocator.c b/3rdparty/dlmalloc/allocator.c
index 510668721..b17909b5b 100644
--- a/3rdparty/dlmalloc/allocator.c
+++ b/3rdparty/dlmalloc/allocator.c
@@ -5,7 +5,10 @@
 #include <openenclave/advanced/mallinfo.h>
 #include <openenclave/enclave.h>
 
-#define HAVE_MMAP 0
+// EDG: use mmap instead of morecore
+#define HAVE_MMAP 1
+#define HAVE_MREMAP 0
+#define HAVE_MORECORE 0
 #define LACKS_UNISTD_H
 #define LACKS_SYS_PARAM_H
 #define LACKS_SYS_TYPES_H
@@ -14,7 +17,7 @@
 #define ABORT oe_abort()
 #define USE_DL_PREFIX
 #define LACKS_STDLIB_H
-#define LACKS_STRING_H
+//#define LACKS_STRING_H
 #define USE_LOCKS 1
 #define fprintf _dlmalloc_stats_fprintf
 #define NO_MALLOC_STATS 1
diff --git a/3rdparty/musl/CMakeLists.txt b/3rdparty/musl/CMakeLists.txt
index 548542535..eab29690d 100644
--- a/3rdparty/musl/CMakeLists.txt
+++ b/3rdparty/musl/CMakeLists.txt
@@ -85,7 +85,8 @@ ExternalProject_Add(
   COMMAND ${CMAKE_COMMAND} -E copy ${PATCHES_DIR}/endian.h
           ${MUSL_INCLUDES}/endian.h
   # Append deprecations.h to all C header files.
-  COMMAND ${OE_BASH} -c "${MUSL_APPEND_DEPRECATIONS}"
+  # EDG: don't deprecate pthread_create and friends
+  #COMMAND ${OE_BASH} -c "${MUSL_APPEND_DEPRECATIONS}"
   # Copy local deprecations.h to include/bits/deprecated.h.
   COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_LIST_DIR}/deprecations.h
           ${MUSL_INCLUDES}/bits/deprecations.h
diff --git a/3rdparty/musl/patches/syscall.h b/3rdparty/musl/patches/syscall.h
index 7bd130f2d..2a58c37e8 100644
--- a/3rdparty/musl/patches/syscall.h
+++ b/3rdparty/musl/patches/syscall.h
@@ -78,10 +78,10 @@ hidden long __syscall_ret(unsigned long), __syscall(syscall_arg_t, ...),
 //       __syscall(SYS_open, a, b, c)
 // is converted to
 //       oe_SYS_open_impl(__scc(a), __scc(b), __scc(c))
-#define __syscall(index, ...) \
-    OE_SYSCALL_NAME(_##index)(SYSCALL_ARGS(__VA_ARGS__))
-#define syscall(index, ...) \
-    __syscall_ret(OE_SYSCALL_NAME(_##index)(SYSCALL_ARGS(__VA_ARGS__)))
+#define syscall(...) __syscall_ret(__syscall(__VA_ARGS__))
+#undef SYS_getdents
+#define SYS_getdents SYS_getdents64
+#define SYS_fadvise SYS_fadvise64
 
 // __syscall_cp and syscall_cp function always pass 6 parameters to the
 // underlying syscall implementation. MUSL sometimes calls these macros instead
@@ -90,10 +90,29 @@ hidden long __syscall_ret(unsigned long), __syscall(syscall_arg_t, ...),
 #define SYSCALL_CP_ARGS_X(a, b, c, d, e, f, ...) SYSCALL_ARGS6(a, b, c, d, e, f)
 #define SYSCALL_CP_ARGS(...) SYSCALL_CP_ARGS_X(__VA_ARGS__, 0, 0, 0, 0, 0, 0)
 
-#define __syscall_cp(index, ...) \
-    OE_SYSCALL_NAME(_##index)(SYSCALL_CP_ARGS(__VA_ARGS__))
-#define syscall_cp(index, ...) \
-    __syscall_ret(OE_SYSCALL_NAME(_##index)(SYSCALL_CP_ARGS(__VA_ARGS__)))
+#define __SYSCALL_NARGS_X(a, b, c, d, e, f, g, h, n, ...) n
+#define __SYSCALL_NARGS(...) \
+    __SYSCALL_NARGS_X(__VA_ARGS__, 7, 6, 5, 4, 3, 2, 1, 0, )
+#define __SYSCALL_CONCAT_X(a, b) a##b
+#define __SYSCALL_CONCAT(a, b) __SYSCALL_CONCAT_X(a, b)
+#define __SYSCALL_DISP(b, ...) \
+    __SYSCALL_CONCAT(b, __SYSCALL_NARGS(__VA_ARGS__))(__VA_ARGS__)
+
+#define __syscall_cp0(n) (__syscall_cp)(n, 0, 0, 0, 0, 0, 0)
+#define __syscall_cp1(n, a) (__syscall_cp)(n, __scc(a), 0, 0, 0, 0, 0)
+#define __syscall_cp2(n, a, b) (__syscall_cp)(n, __scc(a), __scc(b), 0, 0, 0, 0)
+#define __syscall_cp3(n, a, b, c) \
+    (__syscall_cp)(n, __scc(a), __scc(b), __scc(c), 0, 0, 0)
+#define __syscall_cp4(n, a, b, c, d) \
+    (__syscall_cp)(n, __scc(a), __scc(b), __scc(c), __scc(d), 0, 0)
+#define __syscall_cp5(n, a, b, c, d, e) \
+    (__syscall_cp)(n, __scc(a), __scc(b), __scc(c), __scc(d), __scc(e), 0)
+#define __syscall_cp6(n, a, b, c, d, e, f) \
+    (__syscall_cp)(                        \
+        n, __scc(a), __scc(b), __scc(c), __scc(d), __scc(e), __scc(f))
+
+#define __syscall_cp(...) __SYSCALL_DISP(__syscall_cp, __VA_ARGS__)
+#define syscall_cp(...) __syscall_ret(__syscall_cp(__VA_ARGS__))
 
 // Sockets are dispatched via the following macros.
 #ifndef SYSCALL_USE_SOCKETCALL
diff --git a/CMakeLists.txt b/CMakeLists.txt
index aa32b64b5..0defdf988 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -175,7 +175,8 @@ endif ()
 
 if (OE_SGX)
   # Currently we only support OpenSSL on SGX.
-  set(BUILD_OPENSSL ON)
+  # EDG: we use mbedtls only
+  #set(BUILD_OPENSSL ON)
 endif ()
 
 set(DEFAULT_TEST_ENCLAVE_CRYPTO_LIB
@@ -288,7 +289,8 @@ if (CMAKE_CXX_COMPILER_ID MATCHES "GNU" AND CMAKE_CXX_COMPILER_VERSION
                                             VERSION_LESS "7.1")
   set(COMPILER_SUPPORTS_SNMALLOC off)
 else ()
-  set(COMPILER_SUPPORTS_SNMALLOC on)
+  # EDG: no support for snmalloc yet
+  #set(COMPILER_SUPPORTS_SNMALLOC on)
 endif ()
 
 # NOTE: Building OpenEnclave using snmalloc for memory allocation is an experimental option.
@@ -423,9 +425,9 @@ add_subdirectory(tools)
 if (BUILD_ENCLAVES)
   add_subdirectory(enclave)
   add_subdirectory(3rdparty)
-  add_subdirectory(libc)
   add_subdirectory(libcxx)
   add_subdirectory(syscall)
+  add_subdirectory(${ERTSRC} ert)
 endif ()
 
 if (OE_SGX)
diff --git a/cmake/compiler_settings.cmake b/cmake/compiler_settings.cmake
index 90864a682..f51cd9812 100644
--- a/cmake/compiler_settings.cmake
+++ b/cmake/compiler_settings.cmake
@@ -24,7 +24,7 @@ endif ()
 set(CMAKE_C_STANDARD 11)
 
 # Set the default standard to C++14 for all targets.
-set(CMAKE_CXX_STANDARD 14)
+set(CMAKE_CXX_STANDARD 17)
 set(CMAKE_CXX_STANDARD_REQUIRED ON)
 # Do not use, for example, `-std=gnu++14`.
 set(CMAKE_CXX_EXTENSIONS OFF)
diff --git a/common/sgx/collateral.c b/common/sgx/collateral.c
index f4d9fcc76..1118bb1f5 100644
--- a/common/sgx/collateral.c
+++ b/common/sgx/collateral.c
@@ -326,18 +326,46 @@ oe_result_t oe_validate_revocation_list(
                 "Failed to read CRL. %s",
                 oe_result_str(result));
         }
-        // Otherwise, CRL should have v3 structure which is DER encoded
+        // Otherwise, CRL should have v3 or v3.1 structure
+        //    v3 is hex encoded DER
+        //    v3.1 is DER
         else
         {
             size_t der_data_size = sgx_endorsements->items[i].size;
             if (der_data_size == 0)
                 OE_RAISE(OE_INVALID_PARAMETER);
 
-            // If DER CRL buffer has null terminator, need to remove it before
+            // If CRL buffer has null terminator, need to remove it before
             // send the DER data to crypto API for reading.
             if (sgx_endorsements->items[i].data[der_data_size - 1] == 0)
                 der_data_size -= 1;
 
+            // If the CRL is only composed of hex digits we need to manually
+            // convert to DER
+            bool ishex = true;
+            for (size_t l = 0; l < der_data_size; ++l)
+            {
+                const uint8_t c = sgx_endorsements->items[i].data[l];
+                if (!((c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f') ||
+                      (c >= '0' && c <= '9')))
+                {
+                    ishex = false;
+                    break;
+                }
+            }
+            if (ishex)
+            {
+                OE_CHECK_MSG(
+                    oe_hex_to_buf(
+                        (const char*)sgx_endorsements->items[i].data,
+                        der_data_size,
+                        sgx_endorsements->items[i].data,
+                        der_data_size),
+                    "Failed to convert to DER. %s",
+                    oe_result_str(result));
+                der_data_size /= 2;
+            }
+
             OE_CHECK_MSG(
                 oe_crl_read_der(
                     &crls[j], sgx_endorsements->items[i].data, der_data_size),
diff --git a/debugger/gdb-extension/load_symbol_cmd.py b/debugger/gdb-extension/load_symbol_cmd.py
index ca0e0f893..ea04aa53b 100644
--- a/debugger/gdb-extension/load_symbol_cmd.py
+++ b/debugger/gdb-extension/load_symbol_cmd.py
@@ -89,7 +89,7 @@ def GetLoadSymbolCommand(EnclaveFile, Base):
             # Write the GDB 'add-symbol-file' command with all the arguments to the setup GDB command file.
             # Note: The mandatory argument for the 'add-symbol-file' command is the .text section without a
             # '-s .SectionName'.  All other sections need the '-s .SectionName'.
-            gdbcmd = "add-symbol-file '" + EnclaveFile + "' " + '%(Location)#08x' % {'Location':int(Out[99][2])} + " -readnow "
+            gdbcmd = "add-symbol-file '" + EnclaveFile + "' " + '%(Location)#08x' % {'Location':int(Out[99][2])} + " "
             for j in range(i):
                 gdbcmd += Out[j][0] + " " + Out[j][1] + " " + '%(Location)#08x' % {'Location' : int(Out[j][2])} + " " + Out[j][3]
         else:
diff --git a/enclave/core/__stack_chk_fail.c b/enclave/core/__stack_chk_fail.c
index 825e5d10f..ffc34fa20 100644
--- a/enclave/core/__stack_chk_fail.c
+++ b/enclave/core/__stack_chk_fail.c
@@ -3,7 +3,7 @@
 
 #include <openenclave/enclave.h>
 
-void __stack_chk_fail(void)
+OE_EXPORT void __stack_chk_fail(void)
 {
     __oe_assert_fail(
         "Stack smashing detected!", __FILE__, __LINE__, __FUNCTION__);
diff --git a/enclave/core/init_fini.c b/enclave/core/init_fini.c
index 47bfc0d10..1ea5f124e 100644
--- a/enclave/core/init_fini.c
+++ b/enclave/core/init_fini.c
@@ -2,6 +2,7 @@
 // Licensed under the MIT License.
 
 #include "init_fini.h"
+#include <openenclave/ert_args.h>
 #include <openenclave/internal/globals.h>
 
 /*
@@ -60,11 +61,16 @@ static void _call_init_functions(
     void (**init_array_start)(void),
     void (**init_array_end)(void))
 {
-    void (**fn)(void);
+    void (**fn)();
+
+    // EDG: Go expects args to be passed to init functions.
+    const int argc = ert_get_argc();
+    char** const argv = ert_get_argv();
+    char** const envp = ert_get_envp();
 
     for (fn = init_array_start; fn < init_array_end; fn++)
     {
-        (*fn)();
+        (*fn)(argc, argv, envp);
     }
 }
 
diff --git a/enclave/core/sgx/backtrace.c b/enclave/core/sgx/backtrace.c
index b9d64b1b4..4c5f03803 100644
--- a/enclave/core/sgx/backtrace.c
+++ b/enclave/core/sgx/backtrace.c
@@ -68,7 +68,28 @@ const void* _check_address(const void* ptr)
     if (!oe_is_within_enclave(ptr, sizeof(uint64_t)))
         return NULL;
 
-    return ptr;
+    // EDG: We must also check that ptr is not within a guard page of a thread
+    // context. See _add_data_pages() in host/sgx/create.c
+
+    const size_t num_stack_pages = oe_get_num_stack_pages();
+
+    const uintptr_t thread_contexts_start = (uintptr_t)__oe_get_heap_end();
+    const size_t thread_context_size =
+        (1 + num_stack_pages + 1 + 6) * OE_PAGE_SIZE; // see _add_data_pages()
+    const uintptr_t thread_contexts_end =
+        thread_contexts_start + oe_get_num_tcs() * thread_context_size;
+
+    const uintptr_t uptr = (uintptr_t)ptr;
+    if (!(thread_contexts_start <= uptr && uptr < thread_contexts_end))
+        return ptr;
+
+    // ptr is within thread contexts area. Check that it is within stack pages.
+    const size_t page_number =
+        (uptr - thread_contexts_start) % thread_context_size / OE_PAGE_SIZE;
+    if (1 <= page_number && page_number < 1 + num_stack_pages)
+        return ptr;
+
+    return NULL;
 }
 
 /* Safe implementation of backtrace.
diff --git a/enclave/core/sgx/calls.c b/enclave/core/sgx/calls.c
index 6f8ee30f1..4c6eda65a 100644
--- a/enclave/core/sgx/calls.c
+++ b/enclave/core/sgx/calls.c
@@ -46,6 +46,22 @@
 oe_result_t __oe_enclave_status = OE_OK;
 uint8_t __oe_initialized = 0;
 
+bool ert_exiting;
+
+#ifndef NDEBUG
+// EDG: initialized in _handle_ecall() and used in oe_ocall()
+static __thread void** _backtrace_buffer;
+
+oe_result_t _oe_sgx_get_backtrace_buffer_ocall(void*** _retval)
+{
+    (void)_retval;
+    return OE_UNSUPPORTED;
+}
+OE_WEAK_ALIAS(
+    _oe_sgx_get_backtrace_buffer_ocall,
+    oe_sgx_get_backtrace_buffer_ocall);
+#endif
+
 /*
 **==============================================================================
 **
@@ -193,14 +209,20 @@ static oe_result_t _handle_init_enclave(uint64_t arg_in)
             /* Initialize the OE crypto library. */
             oe_crypto_initialize();
 
-            /* Call global constructors. Now they can safely use simulated
-             * instructions like CPUID. */
-            oe_call_init_functions();
+            /* EDG: Initialize args before calling global constructors. */
+            oe_result_t ert_init_args(void);
+            OE_CHECK(ert_init_args());
 
-            /* DCLP Release barrier. */
+            /* EDG: DCLP Release barrier and set initialized before calling
+             * global constructors because they may create threads whose ecall
+             * would otherwise fail. (Go does so.) */
             OE_ATOMIC_MEMORY_BARRIER_RELEASE();
             _once = true;
             __oe_initialized = 1;
+
+            /* Call global constructors. Now they can safely use simulated
+             * instructions like CPUID. */
+            oe_call_init_functions();
         }
 
         oe_spin_unlock(&_lock);
@@ -413,6 +435,9 @@ static void _call_at_exit_functions(void)
     oe_spin_lock(&_lock);
     if (!_at_exit_functions_done)
     {
+        // EDG: notify that enclave is exiting
+        ert_exiting = true;
+
         /* Call functions installed by oe_cxa_atexit() and oe_atexit()
          */
         oe_call_atexit_functions();
@@ -535,6 +560,17 @@ static void _handle_ecall(
         goto done;
     }
 
+    // EDG: initialize backtrace buffer
+#ifndef NDEBUG
+    if (!_backtrace_buffer)
+    {
+        const oe_result_t res =
+            oe_sgx_get_backtrace_buffer_ocall(&_backtrace_buffer);
+        if (res != OE_OK && res != OE_UNSUPPORTED)
+            oe_abort();
+    }
+#endif
+
     /* Dispatch the ECALL */
     switch (func)
     {
@@ -770,6 +806,14 @@ void oe_exit_enclave(uint64_t arg1, uint64_t arg2)
 
 oe_result_t oe_ocall(uint16_t func, uint64_t arg_in, uint64_t* arg_out)
 {
+    // EDG: trace ocalls
+#ifndef NDEBUG
+    if (_backtrace_buffer)
+        // use first array element to store size
+        *(intptr_t*)_backtrace_buffer =
+            oe_backtrace(_backtrace_buffer + 1, OE_BACKTRACE_MAX);
+#endif
+
     oe_result_t result = OE_UNEXPECTED;
     oe_sgx_td_t* td = oe_sgx_get_td();
     oe_callsite_t* callsite = td->callsites;
@@ -817,6 +861,11 @@ oe_result_t oe_ocall(uint16_t func, uint64_t arg_in, uint64_t* arg_out)
         /* ORET here */
     }
 
+    // EDG: Insert cancellation point after ocall (esp. after THREAD_WAIT) so
+    // that pthread_cancel works as expected.
+    void pthread_testcancel();
+    pthread_testcancel();
+
     result = OE_OK;
 
 done:
@@ -1204,6 +1253,10 @@ void __oe_handle_main(
 
 void oe_abort(void)
 {
+    // EDG: print stack trace
+    if (is_enclave_debug_allowed())
+        oe_print_backtrace();
+
     // Once it starts to crash, the state can only transit forward, not
     // backward.
     if (__oe_enclave_status < OE_ENCLAVE_ABORTING)
diff --git a/enclave/core/sgx/exception.c b/enclave/core/sgx/exception.c
index bd61ea6fa..e39d9f15a 100644
--- a/enclave/core/sgx/exception.c
+++ b/enclave/core/sgx/exception.c
@@ -23,6 +23,12 @@ uint32_t g_current_exception_handler_count = 0;
 oe_vectored_exception_handler_t
     g_exception_handler_arr[MAX_EXCEPTION_HANDLER_COUNT];
 
+// EDG: enclave dev can enable SIGSEGV by overriding this symbol
+OE_WEAK bool ert_enable_sigsegv;
+
+__thread uint64_t ert_sigaltstack_sp;
+static __thread uint64_t _original_sp;
+
 oe_result_t oe_add_vectored_exception_handler(
     bool is_first_handler,
     oe_vectored_exception_handler_t vectored_handler)
@@ -237,6 +243,10 @@ int _emulate_illegal_instruction(sgx_ssa_gpr_t* ssa_gpr)
 */
 void oe_real_exception_dispatcher(oe_context_t* oe_context)
 {
+    // EDG: restore sp if sigaltstack has been used
+    if (ert_sigaltstack_sp)
+        oe_context->rsp = _original_sp;
+
     oe_sgx_td_t* td = oe_sgx_get_td();
 
     // Change the rip of oe_context to the real exception address.
@@ -290,6 +300,9 @@ void oe_real_exception_dispatcher(oe_context_t* oe_context)
 
     // Exception can't be handled by trusted handlers, abort the enclave.
     // Let the oe_abort to run on the stack where the exception happens.
+    // EDG: but fix the stack alignment!
+    oe_exception_record.context->rsp &= ~0xFull;
+    oe_exception_record.context->rsp -= 8;
     oe_exception_record.context->rip = (uint64_t)oe_abort;
     oe_continue_execution(oe_exception_record.context);
 
@@ -329,8 +342,15 @@ void oe_virtual_exception_dispatcher(
     if (!ssa_gpr->exit_info.as_fields.valid)
     {
         // Not a valid/expected enclave exception;
-        *arg_out = OE_EXCEPTION_CONTINUE_SEARCH;
-        return;
+        if (!(ert_enable_sigsegv && arg_in == 11)) // EDG: allow SIGSEGV
+        {
+            *arg_out = OE_EXCEPTION_CONTINUE_SEARCH;
+            return;
+        }
+        sgx_exit_info* const ei = &ssa_gpr->exit_info;
+        ei->as_fields.vector = 13; // #GP
+        ei->as_fields.exit_type = SGX_EXIT_TYPE_HARDWARE;
+        ei->as_fields.valid = 1;
     }
 
     // Get the exception address, code, and flags.
@@ -385,6 +405,13 @@ void oe_virtual_exception_dispatcher(
         // Modify the ssa_gpr so that e_resume will go to second pass exception
         // handler.
         ssa_gpr->rip = (uint64_t)oe_exception_dispatcher;
+
+        // EDG: use alternative sp if sigaltstack has been used
+        if (ert_sigaltstack_sp)
+        {
+            _original_sp = ssa_gpr->rsp;
+            ssa_gpr->rsp = ert_sigaltstack_sp;
+        }
     }
 
     // Cleanup the exception flag to avoid the exception handler is called
diff --git a/enclave/core/sgx/globals.c b/enclave/core/sgx/globals.c
index 8e2a907a5..711201682 100644
--- a/enclave/core/sgx/globals.c
+++ b/enclave/core/sgx/globals.c
@@ -178,6 +178,11 @@ uint8_t __oe_get_enclave_create_zero_base_flag()
         oe_enclave_properties_sgx.config.flags.create_zero_base_enclave;
 }
 
+uint64_t oe_get_num_tcs(void)
+{
+    return oe_enclave_properties_sgx.header.size_settings.num_tcs;
+}
+
 /*
 **==============================================================================
 **
@@ -305,3 +310,22 @@ const oe_enclave_module_info_t* oe_get_module_info(void)
 {
     return (const oe_enclave_module_info_t*)&_module_info;
 }
+
+/*
+**==============================================================================
+**
+** Stack:
+**
+**==============================================================================
+*/
+
+size_t oe_get_num_stack_pages(void)
+{
+    return oe_enclave_properties_sgx.header.size_settings.num_stack_pages;
+}
+
+size_t oe_get_stack_size(void)
+{
+    return oe_enclave_properties_sgx.header.size_settings.num_stack_pages *
+           OE_PAGE_SIZE;
+}
diff --git a/enclave/core/sgx/keys.c b/enclave/core/sgx/keys.c
index 28e78c546..23acc8d09 100644
--- a/enclave/core/sgx/keys.c
+++ b/enclave/core/sgx/keys.c
@@ -31,6 +31,22 @@ static oe_result_t _get_key_imp(
     sgx_key_request_t tmp_key_request = *sgx_key_request;
     OE_ALIGNED(SGX_KEY_ALIGNMENT) sgx_key_t tmp_sgx_key;
 
+    // EDG: return test key in simulation mode
+    if (oe_sgx_get_td()->simulate)
+    {
+        // satisfy unit test
+        if (tmp_key_request.key_name != SGX_KEYSELECT_REPORT &&
+            tmp_key_request.key_name != SGX_KEYSELECT_SEAL)
+            return OE_INVALID_KEYNAME;
+        if (tmp_key_request.isv_svn)
+            return OE_INVALID_ISVSVN;
+        if (*tmp_key_request.cpu_svn)
+            return OE_INVALID_CPUSVN;
+
+        *sgx_key = (sgx_key_t){0};
+        return OE_OK;
+    }
+
     // Execute EGETKEY instruction.
     egetkey_result = oe_egetkey(&tmp_key_request, &tmp_sgx_key);
 
@@ -193,10 +209,11 @@ static oe_result_t _get_default_key_request_attributes(
 {
     sgx_report_t sgx_report = {{{0}}};
 
-    oe_result_t result;
+    oe_result_t result = OE_OK;
 
     // Get a local report of current enclave.
-    result = sgx_create_report(NULL, 0, NULL, 0, &sgx_report);
+    if (!oe_sgx_get_td()->simulate) // EDG: skip in simulation mode
+        result = sgx_create_report(NULL, 0, NULL, 0, &sgx_report);
 
     if (result != OE_OK)
     {
diff --git a/enclave/core/sgx/threadlocal.c b/enclave/core/sgx/threadlocal.c
index 098f0d758..9181fbc9d 100644
--- a/enclave/core/sgx/threadlocal.c
+++ b/enclave/core/sgx/threadlocal.c
@@ -286,6 +286,18 @@ oe_result_t oe_thread_local_init(oe_sgx_td_t* td)
         // Copy the template
         oe_memcpy_s(tls_start, _tdata_size, tdata, _tdata_size);
 
+        // EDG: copy payload template
+        const oe_enclave_module_info_t* const modinfo = oe_get_module_info();
+        if (modinfo->tdata_size)
+        {
+            oe_memcpy_s(
+                fs - modinfo->tls_size,
+                modinfo->tdata_size,
+                (uint8_t*)__oe_get_enclave_start_address() + modinfo->base_rva +
+                    modinfo->tdata_rva,
+                modinfo->tdata_size);
+        }
+
         // Perform thread-local relocations, only run once.
         if (!_thread_locals_relocated)
         {
@@ -348,8 +360,10 @@ done:
 /**
  * Register a destructor to be called on the given object when the
  * thread exits. This call is emitted by the compiler.
+ *
+ * EDG: renamed from __cxa_thread_atexit
  */
-void __cxa_thread_atexit(void (*destructor)(void*), void* object)
+void __cxa_thread_atexit_impl(void (*destructor)(void*), void* object)
 {
     oe_sgx_td_t* td = oe_sgx_get_td();
 
@@ -365,6 +379,11 @@ void __cxa_thread_atexit(void (*destructor)(void*), void* object)
     td->tls_atexit_functions[td->num_tls_atexit_functions - 1] = item;
 }
 
+// EDG: stdc++ defines __cxa_thread_atexit which calls
+// __cxa_thread_atexit_impl. So behavior will be the same whether or not stdc++
+// is linked.
+OE_WEAK_ALIAS(__cxa_thread_atexit_impl, __cxa_thread_atexit);
+
 /**
  * Cleanup the thread-local section for a given thread.
  * This must be called *before* the td itself is cleaned up.
diff --git a/enclave/sgx/report.c b/enclave/sgx/report.c
index 752ce5154..424937618 100644
--- a/enclave/sgx/report.c
+++ b/enclave/sgx/report.c
@@ -14,6 +14,7 @@
 #include <openenclave/internal/report.h>
 #include <openenclave/internal/safecrt.h>
 #include <openenclave/internal/sgx/plugin.h>
+#include <openenclave/internal/sgx/td.h>
 #include <openenclave/internal/sgxkeys.h>
 #include <openenclave/internal/utils.h>
 #include <stdlib.h>
@@ -177,6 +178,9 @@ oe_result_t oe_get_report_v2(
     else
         format_id = &_local_uuid;
 
+    if (oe_sgx_get_td()->simulate)
+        OE_RAISE_MSG(OE_UNSUPPORTED, "can't get report in simulation mode");
+
     OE_CHECK(oe_attester_initialize());
 
     OE_CHECK(oe_find_attester_plugin(format_id, &attester));
diff --git a/host/CMakeLists.txt b/host/CMakeLists.txt
index f82e71363..85b78cb23 100644
--- a/host/CMakeLists.txt
+++ b/host/CMakeLists.txt
@@ -333,10 +333,16 @@ list(
   strings.c
   traceh_enclave.c)
 
+# EDG: add erthost
+include(${ERTSRC}/host/erthost.cmake)
+
 # Combine the following common code along with the platform specific code and
 # host verification code to get the full oehost target provided by the OE SDK.
 add_library(oehost STATIC ${PLATFORM_HOST_ONLY_SRC} ${PLATFORM_SDK_ONLY_SRC})
 
+# EDG: add EDL
+add_dependencies(oehost ertlibc_untrusted_edl)
+
 add_library(oehostverify STATIC ${PLATFORM_HOST_ONLY_SRC})
 
 target_link_libraries(oehostverify PUBLIC oe_includes)
@@ -454,7 +460,8 @@ endif ()
 if (UNIX)
   target_compile_options(
     oehost
-    PRIVATE -Wno-attributes -Wmissing-prototypes -fPIC ${PLATFORM_FLAGS}
+    PRIVATE -Wno-attributes $<$<COMPILE_LANGUAGE:C>:-Wmissing-prototypes> -fPIC
+            ${PLATFORM_FLAGS}
     PUBLIC -fstack-protector-strong)
   target_compile_definitions(
     oehost
diff --git a/host/linux/syscall.c b/host/linux/syscall.c
index e3255a942..77351b2ac 100644
--- a/host/linux/syscall.c
+++ b/host/linux/syscall.c
@@ -37,11 +37,15 @@
 oe_host_fd_t oe_syscall_open_ocall(
     const char* pathname,
     int flags,
-    oe_mode_t mode)
+    oe_mode_t mode,
+    uint64_t* dir)
 {
     errno = 0;
 
-    return open(pathname, flags, mode);
+    const int fd = open(pathname, flags, mode);
+    if (fd >= 0)
+        *dir = fdopendir(fd);
+    return fd;
 }
 
 ssize_t oe_syscall_read_ocall(oe_host_fd_t fd, void* buf, size_t count)
@@ -1270,11 +1274,15 @@ int oe_syscall_poll_ocall(
 
     errno = 0;
 
+// EDG: poll with nfds=0 can be used as sleep. (Python uses it this way and it
+// is also documented in the manpage.)
+#if 0
     if (nfds == 0)
     {
         errno = EINVAL;
         goto done;
     }
+#endif
 
     if (!(fds = calloc(nfds, sizeof(struct oe_pollfd))))
     {
diff --git a/host/sgx/calls.c b/host/sgx/calls.c
index d510591b7..dcf5b2f39 100644
--- a/host/sgx/calls.c
+++ b/host/sgx/calls.c
@@ -36,6 +36,8 @@
 #include "enclave.h"
 #include "ocalls/ocalls.h"
 
+void ert_trace_ocall(oe_enclave_t* enclave, const void* func);
+
 /*
 **==============================================================================
 **
@@ -246,6 +248,8 @@ oe_result_t oe_handle_call_host_function(uint64_t arg, oe_enclave_t* enclave)
         goto done;
     }
 
+    ert_trace_ocall(enclave, func);
+
     OE_CHECK(oe_safe_add_u64(
         args_ptr->input_buffer_size,
         args_ptr->output_buffer_size,
@@ -358,22 +362,27 @@ static oe_result_t _handle_ocall(
             break;
 
         case OE_OCALL_MALLOC:
+            ert_trace_ocall(enclave, HandleMalloc);
             HandleMalloc(arg_in, arg_out);
             break;
 
         case OE_OCALL_FREE:
+            ert_trace_ocall(enclave, HandleFree);
             HandleFree(arg_in);
             break;
 
         case OE_OCALL_THREAD_WAIT:
+            ert_trace_ocall(enclave, HandleThreadWait);
             HandleThreadWait(enclave, arg_in);
             break;
 
         case OE_OCALL_THREAD_WAKE:
+            ert_trace_ocall(enclave, HandleThreadWake);
             HandleThreadWake(enclave, arg_in);
             break;
 
         case OE_OCALL_GET_TIME:
+            ert_trace_ocall(enclave, oe_handle_get_time);
             oe_handle_get_time(arg_in, arg_out);
             break;
 
@@ -384,6 +393,10 @@ static oe_result_t _handle_ocall(
         }
     }
 
+    // EDG: Insert cancellation point after ocall (esp. after THREAD_WAIT) so
+    // that EnclaveThreadManager is able to cancel enclave threads.
+    pthread_testcancel();
+
     result = OE_OK;
 
 done:
diff --git a/host/sgx/create.c b/host/sgx/create.c
index 512283c0b..f3853bc27 100644
--- a/host/sgx/create.c
+++ b/host/sgx/create.c
@@ -121,7 +121,8 @@ static oe_result_t _add_filled_pages(
     uint64_t* vaddr,
     size_t npages,
     uint32_t filler,
-    bool extend)
+    bool extend,
+    bool executable)
 {
     oe_result_t result = OE_UNEXPECTED;
     oe_page_t* page = NULL;
@@ -154,6 +155,10 @@ static oe_result_t _add_filled_pages(
         uint64_t src = (uint64_t)page;
         uint64_t flags = SGX_SECINFO_REG | SGX_SECINFO_R | SGX_SECINFO_W;
 
+        // EDG: add executable flag
+        if (executable)
+            flags |= SGX_SECINFO_X;
+
         OE_CHECK(oe_sgx_load_enclave_data(
             context, enclave->base_address, addr, src, flags, extend));
         (*vaddr) += OE_PAGE_SIZE;
@@ -176,7 +181,7 @@ static oe_result_t _add_stack_pages(
 {
     const bool extend = true;
     return _add_filled_pages(
-        context, enclave, vaddr, npages, 0xcccccccc, extend);
+        context, enclave, vaddr, npages, 0xcccccccc, extend, false);
 }
 
 static oe_result_t _add_heap_pages(
@@ -187,7 +192,8 @@ static oe_result_t _add_heap_pages(
 {
     /* Do not measure heap pages */
     const bool extend = false;
-    return _add_filled_pages(context, enclave, vaddr, npages, 0, extend);
+    return _add_filled_pages(
+        context, enclave, vaddr, npages, 0, extend, context->executable_heap);
 }
 
 static oe_result_t _add_control_pages(
@@ -301,7 +307,7 @@ static oe_result_t _add_control_pages(
     }
 
     /* Add two blank pages */
-    OE_CHECK(_add_filled_pages(context, enclave, vaddr, 2, 0, true));
+    OE_CHECK(_add_filled_pages(context, enclave, vaddr, 2, 0, true, false));
 
     /* Skip over guard page */
     (*vaddr) += OE_PAGE_SIZE;
@@ -309,10 +315,10 @@ static oe_result_t _add_control_pages(
     /* Add blank pages (for either FS segment or GS segment) */
     if (tls_page_count)
         OE_CHECK(_add_filled_pages(
-            context, enclave, vaddr, tls_page_count, 0, true));
+            context, enclave, vaddr, tls_page_count, 0, true, false));
 
     /* Add one page for thread-specific data (TSD) slots */
-    OE_CHECK(_add_filled_pages(context, enclave, vaddr, 1, 0, true));
+    OE_CHECK(_add_filled_pages(context, enclave, vaddr, 1, 0, true, false));
 
     result = OE_OK;
 
@@ -796,11 +802,76 @@ done:
 }
 #endif
 
+// EDG: extended oeinfo section
+typedef struct
+{
+    oe_sgx_enclave_properties_t props;
+    uint8_t _pad[0x800 - sizeof(oe_sgx_enclave_properties_t)];
+    uint64_t payload_data_offset;
+    uint64_t payload_data_size;
+} ert_sgx_enclave_properties_t;
+
+static oe_result_t _add_readonly_page(
+    oe_sgx_load_context_t* context,
+    uint64_t enclave_addr,
+    uint64_t* vaddr,
+    const void* page)
+{
+    oe_result_t result = OE_UNEXPECTED;
+    OE_CHECK(oe_sgx_load_enclave_data(
+        context,
+        enclave_addr,
+        enclave_addr + *vaddr,
+        (uint64_t)page,
+        SGX_SECINFO_R | SGX_SECINFO_REG,
+        true));
+    *vaddr += OE_PAGE_SIZE;
+    result = OE_OK;
+done:
+    return result;
+}
+
+static oe_result_t _add_readonly_pages(
+    oe_sgx_load_context_t* context,
+    uint64_t enclave_addr,
+    uint64_t* vaddr,
+    const uint8_t* data,
+    size_t size)
+{
+    oe_result_t result = OE_UNEXPECTED;
+
+    // _add_readonly_page() requires page-aligned input
+    uint8_t* const page = oe_memalign(OE_PAGE_SIZE, sizeof(oe_page_t));
+    if (!page)
+        OE_RAISE(OE_OUT_OF_MEMORY);
+
+    for (size_t i = 0; i < size / OE_PAGE_SIZE; ++i)
+    {
+        memcpy(page, data + i * OE_PAGE_SIZE, OE_PAGE_SIZE);
+        OE_CHECK(_add_readonly_page(context, enclave_addr, vaddr, page));
+    }
+
+    const size_t remaining = size % OE_PAGE_SIZE;
+    if (remaining)
+    {
+        memcpy(page, data + size - remaining, remaining);
+        memset(page + remaining, 0, OE_PAGE_SIZE - remaining);
+        OE_CHECK(_add_readonly_page(context, enclave_addr, vaddr, page));
+    }
+
+    result = OE_OK;
+
+done:
+    oe_memalign_free(page);
+    return result;
+}
+
 oe_result_t oe_sgx_build_enclave(
     oe_sgx_load_context_t* context,
     const char* path,
     const oe_sgx_enclave_properties_t* properties,
-    oe_enclave_t* enclave)
+    oe_enclave_t* enclave,
+    const char* payload_path)
 {
     oe_result_t result = OE_UNEXPECTED;
     size_t loaded_enclave_pages_size = 0;
@@ -812,6 +883,7 @@ oe_result_t oe_sgx_build_enclave(
     size_t tls_page_count;
     uint64_t vaddr = 0;
     oe_sgx_enclave_properties_t props;
+    uint64_t payload_data_offset = 0;
 
     /* Reject invalid parameters */
     if (!context || !path || !enclave)
@@ -833,7 +905,7 @@ oe_result_t oe_sgx_build_enclave(
         OE_RAISE(OE_FAILURE);
 
     /* Load the elf object */
-    if (oe_load_enclave_image(path, &oeimage) != OE_OK)
+    if (oe_load_enclave_image(path, &oeimage, payload_path) != OE_OK)
         OE_RAISE(OE_FAILURE);
 
     // If the **properties** parameter is non-null, use those properties.
@@ -857,6 +929,47 @@ oe_result_t oe_sgx_build_enclave(
             sizeof(props));
     }
 
+    // EDG: load payload image
+    if (payload_path)
+    {
+        oe_enclave_elf_image_t* const submod = oeimage.submodule;
+
+        // use props from payload
+        if (properties)
+            memcpy(
+                submod->image_base + submod->oeinfo_rva, &props, sizeof(props));
+        else
+        {
+            memcpy(
+                &props, submod->image_base + submod->oeinfo_rva, sizeof(props));
+            memcpy(
+                oeimage.elf.image_base + oeimage.elf.oeinfo_rva,
+                &props,
+                sizeof(props));
+        }
+
+        ert_sgx_enclave_properties_t* const props_payload =
+            (ert_sgx_enclave_properties_t*)(submod->image_base + submod->oeinfo_rva);
+
+        // Clear the hash when taking the measure
+        memset(
+            props_payload->props.sigstruct,
+            0,
+            sizeof(props_payload->props.sigstruct));
+
+        // ensure that payload data is within bounds of the file
+        uint64_t payload_data_end = 0;
+        OE_CHECK(oe_safe_add_u64(
+            props_payload->payload_data_offset,
+            props_payload->payload_data_size,
+            &payload_data_end));
+        if (payload_data_end > submod->elf.size)
+            OE_RAISE(OE_OUT_OF_BOUNDS);
+
+        payload_data_offset = props_payload->payload_data_offset;
+        submod->payload_data_size = props_payload->payload_data_size;
+    }
+
     /* Validate the enclave prop_override structure */
     OE_CHECK(oe_sgx_validate_enclave_properties(&props, NULL));
 
@@ -902,7 +1015,9 @@ oe_result_t oe_sgx_build_enclave(
 
     /* Calculate the size of this enclave in memory */
     OE_CHECK(_calculate_enclave_size(
-        image_size,
+        image_size +
+            oe_round_up_to_page_size(
+                oeimage.submodule ? oeimage.submodule->payload_data_size : 0),
         tls_page_count,
         &props,
         &loaded_enclave_pages_size,
@@ -990,6 +1105,22 @@ oe_result_t oe_sgx_build_enclave(
         &vaddr));
 #endif
 
+    // EDG: Check if the enclave is configured with ExecutableHeap=1
+    context->executable_heap = props.config.flags.executable_heap;
+
+    // EDG: add payload data to enclave
+    if (payload_data_offset)
+    {
+        const uint8_t* const data =
+            (uint8_t*)oeimage.submodule->elf.data + payload_data_offset;
+        OE_CHECK(_add_readonly_pages(
+            context,
+            enclave_addr,
+            &vaddr,
+            data,
+            oeimage.submodule->payload_data_size));
+    }
+
     /* Add data pages */
     OE_CHECK(_add_data_pages(
         context,
@@ -1203,8 +1334,21 @@ oe_result_t oe_create_enclave(
 #endif
     }
 
-    /* Build the enclave */
-    OE_CHECK(oe_sgx_build_enclave(&context, enclave_path, NULL, enclave));
+    // EDG: split enclave_path which is either "main_image" or
+    // "main_image:payload_image"
+    if (!*enclave_path)
+        OE_RAISE(OE_FAILURE);
+    {
+        char* const paths = strdup(enclave_path);
+        enclave_path = strtok(paths, ":");
+        const char* const payload_path = strtok(NULL, ":");
+
+        /* Build the enclave */
+        OE_CHECK(oe_sgx_build_enclave(
+            &context, enclave_path, NULL, enclave, payload_path));
+
+        free(paths);
+    }
 
     /* Push the new created enclave to the global list. */
     if (oe_push_enclave_instance(enclave) != 0)
@@ -1280,6 +1424,10 @@ oe_result_t oe_terminate_enclave(oe_enclave_t* enclave)
     if (!enclave || enclave->magic != ENCLAVE_MAGIC)
         OE_RAISE(OE_INVALID_PARAMETER);
 
+    /* EDG: cancel lingering threads (if any) */
+    oe_result_t ert_cancel_threads_created_inside_enclave(oe_enclave_t*);
+    OE_CHECK(ert_cancel_threads_created_inside_enclave(enclave));
+
     /* Call the atexit functions (e.g., registered by atexit or the
      * destructor attribute) */
     result = oe_ecall(enclave, OE_ECALL_CALL_AT_EXIT_FUNCTIONS, 0, NULL);
diff --git a/host/sgx/exception.c b/host/sgx/exception.c
index 273e68e5e..619e3933b 100644
--- a/host/sgx/exception.c
+++ b/host/sgx/exception.c
@@ -47,8 +47,11 @@ uint64_t oe_host_handle_exception(oe_host_exception_context_t* context)
 
         // Call into enclave first pass exception handler.
         uint64_t arg_out = 0;
-        oe_result_t result =
-            oe_ecall(enclave, OE_ECALL_VIRTUAL_EXCEPTION_HANDLER, 0, &arg_out);
+        oe_result_t result = oe_ecall(
+            enclave,
+            OE_ECALL_VIRTUAL_EXCEPTION_HANDLER,
+            (uint64_t)context->sig_num,
+            &arg_out);
 
         // Reset the flag
         thread_data->flags &= (~_OE_THREAD_HANDLING_EXCEPTION);
diff --git a/host/sgx/exception.h b/host/sgx/exception.h
index 0552194e7..a86ad4800 100644
--- a/host/sgx/exception.h
+++ b/host/sgx/exception.h
@@ -12,6 +12,7 @@ typedef struct _host_exception_context
     uint64_t rax;
     uint64_t rbx;
     uint64_t rip;
+    int sig_num;
 } oe_host_exception_context_t;
 
 /* Initialize the exception processing. */
diff --git a/host/sgx/linux/exception.c b/host/sgx/linux/exception.c
index 6242e15f5..300d50a8c 100644
--- a/host/sgx/linux/exception.c
+++ b/host/sgx/linux/exception.c
@@ -37,6 +37,7 @@ static void _host_signal_handler(
     host_context.rax = (uint64_t)context->uc_mcontext.gregs[REG_RAX];
     host_context.rbx = (uint64_t)context->uc_mcontext.gregs[REG_RBX];
     host_context.rip = (uint64_t)context->uc_mcontext.gregs[REG_RIP];
+    host_context.sig_num = sig_num;
 
     // Call platform neutral handler.
     uint64_t action = oe_host_handle_exception(&host_context);
diff --git a/host/sgx/load.c b/host/sgx/load.c
index 4ec690dd7..2f5e827b8 100644
--- a/host/sgx/load.c
+++ b/host/sgx/load.c
@@ -45,7 +45,10 @@ done:
     return result;
 }
 
-oe_result_t oe_load_enclave_image(const char* path, oe_enclave_image_t* image)
+oe_result_t oe_load_enclave_image(
+    const char* path,
+    oe_enclave_image_t* image,
+    const char* payload_path)
 {
     oe_result_t result = OE_UNEXPECTED;
     oe_image_type type;
@@ -60,7 +63,7 @@ oe_result_t oe_load_enclave_image(const char* path, oe_enclave_image_t* image)
         case OE_IMAGE_TYPE_NONE:
             OE_RAISE_MSG(OE_FAILURE, "Bad image type:OE_IMAGE_TYPE_NONE", NULL);
         case OE_IMAGE_TYPE_ELF:
-            OE_RAISE(oe_load_elf_enclave_image(path, image));
+            OE_RAISE(oe_load_elf_enclave_image(path, image, payload_path));
     }
 done:
     return result;
diff --git a/host/sgx/loadelf.c b/host/sgx/loadelf.c
index 70f32572b..19a68334b 100644
--- a/host/sgx/loadelf.c
+++ b/host/sgx/loadelf.c
@@ -740,6 +740,7 @@ static oe_result_t _link_elf_image(
     uint64_t nrelocs = 0;
     const elf64_sym_t* symtab = NULL;
     size_t symtab_size = 0;
+    int missing_symbols_count = 0;
 
     if (elf64_get_dynamic_symbol_table(&image->elf, &symtab, &symtab_size) != 0)
         goto done;
@@ -802,12 +803,12 @@ static oe_result_t _link_elf_image(
             else
             {
                 if ((symbol->st_info >> 4) != STB_WEAK)
-                    OE_RAISE_MSG(
-                        OE_UNSUPPORTED_ENCLAVE_IMAGE,
-                        "symbol %s not found\n",
-                        name);
+                {
+                    ++missing_symbols_count;
+                    OE_TRACE_ERROR("symbol not found: %s", name);
+                }
                 else
-                    OE_TRACE_WARNING("Weak symbol %s is not resolved\n");
+                    OE_TRACE_WARNING("weak symbol is not resolved: %s", name);
             }
         }
         /* Patch non-symbolic relocation records */
@@ -818,6 +819,12 @@ static oe_result_t _link_elf_image(
         }
     }
 
+    if (missing_symbols_count)
+        OE_RAISE_MSG(
+            OE_UNSUPPORTED_ENCLAVE_IMAGE,
+            "%d symbols not found",
+            missing_symbols_count);
+
     result = OE_OK;
 
 done:
@@ -898,6 +905,11 @@ done:
     return result;
 }
 
+static uint64_t _get_aligned_size(uint64_t size, uint64_t align)
+{
+    return align ? oe_round_up_to_multiple(size, align) : size;
+}
+
 static oe_result_t _patch_elf_image(
     oe_enclave_elf_image_t* image,
     oe_enclave_elf_image_t* module_image,
@@ -1009,6 +1021,34 @@ static oe_result_t _patch_elf_image(
                 &module_info->fini_array_rva));
             module_info->fini_array_size = fini_section.sh_size;
         }
+
+        // EDG: patch payload data size
+        module_info->payload_data_size = module_image->payload_data_size;
+        oeprops->image_info.heap_rva +=
+            oe_round_up_to_page_size(module_image->payload_data_size);
+
+        // EDG: payload tls
+        const uint64_t module_tls_size =
+            _get_aligned_size(
+                module_image->tbss_size, module_image->tbss_align) +
+            _get_aligned_size(
+                module_image->tdata_size, module_image->tdata_align);
+        elf64_sym_t sym_reserved_tls = {0};
+        elf64_find_dynamic_symbol_by_name(
+            &image->elf, "ert_reserved_tls", &sym_reserved_tls);
+        if (sym_reserved_tls.st_size < module_tls_size)
+            OE_RAISE_MSG(
+                OE_INVALID_IMAGE,
+                "payload image needs %lu bytes TLS, but main image only "
+                "reserved %lu bytes",
+                module_tls_size,
+                sym_reserved_tls.st_size);
+        if (module_image->tdata_size)
+        {
+            module_info->tdata_rva = module_image->tdata_rva;
+            module_info->tdata_size = module_image->tdata_size;
+            module_info->tls_size = module_tls_size;
+        }
     }
 
     /* Clear the hash when taking the measure */
@@ -1374,8 +1414,12 @@ done:
 
 static oe_result_t _load_dependent_image(
     const char* enclave_path,
-    oe_enclave_image_t* image)
+    oe_enclave_image_t* image,
+    const char* payload_path)
 {
+    if (payload_path == (void*)1)
+        return OE_OK;
+
     oe_result_t result = OE_UNEXPECTED;
     char* module_path = NULL;
     oe_enclave_elf_image_t* module_image = NULL;
@@ -1394,13 +1438,16 @@ static oe_result_t _load_dependent_image(
                 "Failed to locate the module. Please place the module under "
                 "the same directory as the enclave binary.",
                 NULL);
-
+        payload_path = module_path;
+    }
+    if (payload_path)
+    {
         module_image =
             (oe_enclave_elf_image_t*)calloc(1, sizeof(*module_image));
         if (!module_image)
             OE_RAISE(OE_OUT_OF_MEMORY);
 
-        OE_CHECK(_load_elf_image(module_path, module_image));
+        OE_CHECK(_load_elf_image(payload_path, module_image));
         /* Update the RVA for the module */
         module_image->image_rva = image->elf.image_size;
         image->submodule = module_image;
@@ -1435,7 +1482,8 @@ done:
 
 oe_result_t oe_load_elf_enclave_image(
     const char* path,
-    oe_enclave_image_t* image)
+    oe_enclave_image_t* image,
+    const char* payload_path)
 {
     oe_result_t result = OE_UNEXPECTED;
 
@@ -1445,7 +1493,7 @@ oe_result_t oe_load_elf_enclave_image(
     OE_CHECK(_load_primary_image(path, &image->elf));
 
     /* Load the dependent image into memory */
-    OE_CHECK(_load_dependent_image(path, image));
+    OE_CHECK(_load_dependent_image(path, image, payload_path));
 
     /* Patch relocations right after the image loading
      * and make the relocation data size page-aligned. */
diff --git a/include/openenclave/bits/fs.h b/include/openenclave/bits/fs.h
index f7220c44f..d3623bfa1 100644
--- a/include/openenclave/bits/fs.h
+++ b/include/openenclave/bits/fs.h
@@ -24,6 +24,7 @@ OE_EXTERNC_BEGIN
  * **filesystemtype** parameter).
  */
 #define OE_HOST_FILE_SYSTEM "oe_host_file_system"
+#define OE_HOST_FILE_SYSTEM_MMAP "oe_host_file_system_mmap"
 
 OE_EXTERNC_END
 
diff --git a/include/openenclave/bits/sgx/sgxproperties.h b/include/openenclave/bits/sgx/sgxproperties.h
index 42b6b572e..bf24bfebd 100644
--- a/include/openenclave/bits/sgx/sgxproperties.h
+++ b/include/openenclave/bits/sgx/sgxproperties.h
@@ -26,7 +26,7 @@ typedef struct _oe_sgx_enclave_image_info_t
 } oe_sgx_enclave_image_info_t;
 
 /* Max number of threads in an enclave supported */
-#define OE_SGX_MAX_TCS 32
+#define OE_SGX_MAX_TCS 64
 
 // oe_sgx_enclave_properties_t SGX enclave properties derived type
 #define OE_SGX_FLAGS_DEBUG 0x0000000000000002ULL
@@ -38,7 +38,9 @@ typedef struct _oe_sgx_enclave_flags_t
 {
     uint32_t capture_pf_gp_exceptions : 1;
     uint32_t create_zero_base_enclave : 1;
-    uint32_t reserved : 30;
+    // EDG: additional flags
+    uint32_t executable_heap : 1;
+    uint32_t reserved : 29;
 } oe_sgx_enclave_flags_t;
 
 typedef struct oe_sgx_enclave_config_t
diff --git a/include/openenclave/edl/fcntl.edl b/include/openenclave/edl/fcntl.edl
index 5a28f71af..a8cf8939b 100644
--- a/include/openenclave/edl/fcntl.edl
+++ b/include/openenclave/edl/fcntl.edl
@@ -56,7 +56,8 @@ enclave
         oe_host_fd_t oe_syscall_open_ocall(
             [in, string] const char* pathname,
             int flags,
-            oe_mode_t mode)
+            oe_mode_t mode,
+            [out] uint64_t* dir)
             propagate_errno;
 
         ssize_t oe_syscall_read_ocall(
@@ -198,5 +199,27 @@ enclave
             uint64_t argsize,
             [in,out,size=argsize] void* argout)
             propagate_errno;
+
+        oe_host_fd_t ert_mmapfs_open_ocall(
+            [in, string] const char* pathname,
+            int flags,
+            oe_mode_t mode,
+            [out] void** region,
+            [out] size_t* file_size)
+            propagate_errno;
+
+        bool ert_mmapfs_close_ocall(
+            oe_host_fd_t fd,
+            int flags,
+            [user_check] void* region,
+            size_t file_size)
+            propagate_errno;
+
+        void* ert_mmapfs_extend_ocall(
+            oe_host_fd_t fd,
+            [user_check] void* region,
+            size_t file_size,
+            size_t new_region)
+            propagate_errno;
     };
 };
diff --git a/include/openenclave/edl/sgx/debug.edl b/include/openenclave/edl/sgx/debug.edl
index 7b86fc8b8..89d2643bc 100644
--- a/include/openenclave/edl/sgx/debug.edl
+++ b/include/openenclave/edl/sgx/debug.edl
@@ -29,5 +29,7 @@ enclave
             [out, size=symbols_buffer_size] void* symbols_buffer,
             size_t symbols_buffer_size,
             [out] size_t* symbols_buffer_size_out);
+
+        void** oe_sgx_get_backtrace_buffer_ocall();
     };
 };
diff --git a/include/openenclave/edl/sgx/thread.edl b/include/openenclave/edl/sgx/thread.edl
index af2f301b0..a278851fe 100644
--- a/include/openenclave/edl/sgx/thread.edl
+++ b/include/openenclave/edl/sgx/thread.edl
@@ -17,11 +17,27 @@ enclave
     // intentionally kept in host memory.
     include "openenclave/bits/types.h"
 
+    struct oe_sgx_thread_timedwait_ocall_timespec
+    {
+        time_t tv_sec;
+        long tv_nsec;
+    };
+
     untrusted
     {
         void oe_sgx_thread_wake_wait_ocall(
             [user_check] oe_enclave_t* oe_enclave,
             uint64_t waiter_tcs,
             uint64_t self_tcs);
+
+        int oe_sgx_thread_timedwait_ocall(
+            [user_check] oe_enclave_t* oe_enclave,
+            uint64_t tcs,
+            [in] const struct oe_sgx_thread_timedwait_ocall_timespec* timeout);
+
+        void oe_sgx_thread_wake_multiple_ocall(
+            [user_check] oe_enclave_t* oe_enclave,
+            [in, count=tcs_size] const uint64_t* tcs,
+            size_t tcs_size);
     };
 };
diff --git a/include/openenclave/edl/syscall.edl b/include/openenclave/edl/syscall.edl
index 38f075434..7b7a083f7 100644
--- a/include/openenclave/edl/syscall.edl
+++ b/include/openenclave/edl/syscall.edl
@@ -30,4 +30,11 @@ enclave {
     from "openenclave/edl/time.edl" import *;
     from "openenclave/edl/unistd.edl" import *;
     from "openenclave/edl/utsname.edl" import *;
+
+    untrusted {
+        oe_host_fd_t oe_syscall_eventfd_ocall(
+            unsigned int initval,
+            int flags)
+            propagate_errno;
+    };
 };
diff --git a/include/openenclave/host.h b/include/openenclave/host.h
index d0f279ec5..cf32117c2 100644
--- a/include/openenclave/host.h
+++ b/include/openenclave/host.h
@@ -231,6 +231,18 @@ oe_result_t oe_create_enclave(
     uint32_t ecall_count,
     oe_enclave_t** enclave);
 
+/**
+ * Join all threads that have been created from inside the enclave.
+ *
+ * This function should be called before **oe_terminate_enclave()**.
+ *
+ * @param enclave The instance of the enclave whose threads should be joined.
+ *
+ * @returns Returns OE_OK on success.
+ *
+ */
+oe_result_t ert_join_threads_created_inside_enclave(oe_enclave_t* enclave);
+
 /**
  * Terminate an enclave and reclaims its resources.
  *
diff --git a/include/openenclave/internal/globals.h b/include/openenclave/internal/globals.h
index 0e94f7237..6e10cbe48 100644
--- a/include/openenclave/internal/globals.h
+++ b/include/openenclave/internal/globals.h
@@ -18,6 +18,7 @@ const void* __oe_get_enclave_elf_header(void);
 uint8_t __oe_get_enclave_create_zero_base_flag(void);
 size_t __oe_get_enclave_size(void);
 uint64_t __oe_get_configured_enclave_start_address(void);
+uint64_t oe_get_num_tcs(void);
 
 /* Reloc */
 const void* __oe_get_reloc_base(void);
@@ -43,6 +44,10 @@ const void* __oe_get_eeid(void);
 
 const oe_enclave_module_info_t* oe_get_module_info(void);
 
+/* Stack */
+size_t oe_get_num_stack_pages(void);
+size_t oe_get_stack_size(void);
+
 OE_EXTERNC_END
 
 #endif /* _OE_GLOBALS_H */
diff --git a/include/openenclave/internal/load.h b/include/openenclave/internal/load.h
index 0d1875aa7..e27dd8304 100644
--- a/include/openenclave/internal/load.h
+++ b/include/openenclave/internal/load.h
@@ -77,6 +77,9 @@ struct _oe_enclave_elf_image
     /* Offset to write back to the file oe_sgx_enclave_properties_t
      * during signing */
     uint64_t oeinfo_file_pos;
+
+    // EDG: payload properties
+    uint64_t payload_data_size;
 };
 
 typedef enum _oe_image_type
@@ -129,11 +132,15 @@ struct _oe_enclave_image
     oe_result_t (*unload)(oe_enclave_image_t* image);
 };
 
-oe_result_t oe_load_enclave_image(const char* path, oe_enclave_image_t* image);
+oe_result_t oe_load_enclave_image(
+    const char* path,
+    oe_enclave_image_t* image,
+    const char* payload_path);
 
 oe_result_t oe_load_elf_enclave_image(
     const char* path,
-    oe_enclave_image_t* image);
+    oe_enclave_image_t* image,
+    const char* payload_path);
 
 oe_result_t oe_unload_enclave_image(oe_enclave_image_t* oeimage);
 
diff --git a/include/openenclave/internal/module.h b/include/openenclave/internal/module.h
index 2d720612b..e4043f759 100644
--- a/include/openenclave/internal/module.h
+++ b/include/openenclave/internal/module.h
@@ -21,6 +21,12 @@ typedef struct _oe_enclave_module_info
      * indicates that the module does not implement such functions. */
     uint64_t fini_array_rva;
     uint64_t fini_array_size;
+
+    // EDG: payload properties
+    uint64_t payload_data_size;
+    uint64_t tdata_rva;
+    uint64_t tdata_size;
+    uint64_t tls_size;
 } oe_enclave_module_info_t;
 
 OE_EXTERNC_END
diff --git a/include/openenclave/internal/sgxcreate.h b/include/openenclave/internal/sgxcreate.h
index 2a5b4c50c..041e1814e 100644
--- a/include/openenclave/internal/sgxcreate.h
+++ b/include/openenclave/internal/sgxcreate.h
@@ -75,6 +75,9 @@ struct _oe_sgx_load_context
 
     bool create_zero_base_enclave;
     uint64_t start_address; /* Valid only if create_zero_base_enclave is True */
+
+    // EDG: additional fields
+    bool executable_heap;
 };
 
 oe_result_t oe_sgx_initialize_load_context(
@@ -88,7 +91,8 @@ oe_result_t oe_sgx_build_enclave(
     oe_sgx_load_context_t* context,
     const char* path,
     const oe_sgx_enclave_properties_t* properties,
-    oe_enclave_t* enclave);
+    oe_enclave_t* enclave,
+    const char* payload_path);
 
 /**
  * Validate certain fields of an SGX enclave properties structure.
diff --git a/include/openenclave/internal/syscall/device.h b/include/openenclave/internal/syscall/device.h
index 5bed20bf8..1ec1cb5ca 100644
--- a/include/openenclave/internal/syscall/device.h
+++ b/include/openenclave/internal/syscall/device.h
@@ -31,6 +31,12 @@ enum
 
     /* The host epoll device. */
     OE_DEVID_HOST_EPOLL,
+
+    /* The non-secure host mmap file system. */
+    OE_DEVID_HOST_FILE_SYSTEM_MMAP,
+
+    /* Base id for custom devices. Must be last. */
+    OE_DEVID_CUSTOM,
 };
 
 /* Device names. */
@@ -152,6 +158,9 @@ oe_device_t* oe_device_table_find(const char* name, oe_device_type_t type);
 /* Remove the given device from the table and call its release() method. */
 int oe_device_table_remove(uint64_t devid);
 
+/* Get a unique id for a custom device. */
+uint64_t oe_device_table_get_custom_devid(void);
+
 /**
  * Associate a device id with the current thread.
  *
diff --git a/include/openenclave/internal/syscall/raise.h b/include/openenclave/internal/syscall/raise.h
index 5f328735d..6c15cb5c4 100644
--- a/include/openenclave/internal/syscall/raise.h
+++ b/include/openenclave/internal/syscall/raise.h
@@ -16,7 +16,7 @@ OE_EXTERNC_BEGIN
     do                                                         \
     {                                                          \
         int __err = ERRNO;                                     \
-        oe_log(OE_LOG_LEVEL_ERROR, "oe_errno=%d [%s %s:%d]\n", \
+        oe_log(OE_LOG_LEVEL_WARNING, "oe_errno=%d [%s %s:%d]\n", \
             __err, __FILE__, __FUNCTION__, __LINE__);          \
         oe_errno = __err;                                      \
         goto done;                                             \
@@ -29,7 +29,7 @@ OE_EXTERNC_BEGIN
     do                                                              \
     {                                                               \
         int __err = ERRNO;                                          \
-        oe_log(OE_LOG_LEVEL_ERROR, FMT " oe_errno=%d [%s %s:%d]\n", \
+        oe_log(OE_LOG_LEVEL_WARNING, FMT " oe_errno=%d [%s %s:%d]\n", \
            ##__VA_ARGS__, __err, __FILE__, __FUNCTION__, __LINE__); \
         oe_errno = __err;                                           \
         goto done;                                                  \
diff --git a/include/openenclave/internal/syscall/unistd.h b/include/openenclave/internal/syscall/unistd.h
index 095a16d1e..e152df4c7 100644
--- a/include/openenclave/internal/syscall/unistd.h
+++ b/include/openenclave/internal/syscall/unistd.h
@@ -9,6 +9,7 @@
 #include <openenclave/bits/types.h>
 #include <openenclave/corelibc/bits/types.h>
 #include <openenclave/corelibc/stdarg.h>
+#include <openenclave/internal/syscall/types.h>
 #include <openenclave/internal/syscall/unistd.h>
 
 OE_EXTERNC_BEGIN
@@ -74,6 +75,8 @@ int oe_chdir(const char* path);
 
 int oe_close(int fd);
 
+int oe_close_hostfd(oe_host_fd_t fd);
+
 int oe_gethostname(char* name, size_t len);
 
 int oe_getdomainname(char* name, size_t len);
diff --git a/include/openenclave/internal/utils.h b/include/openenclave/internal/utils.h
index 82337b74e..56a6b433d 100644
--- a/include/openenclave/internal/utils.h
+++ b/include/openenclave/internal/utils.h
@@ -228,6 +228,33 @@ OE_INLINE void oe_mem_reverse_inplace(void* mem, size_t n)
     }
 }
 
+OE_INLINE unsigned char oe_hex_digit_to_num(char c)
+{
+    if (c >= '0' && c <= '9')
+        return (unsigned char)(c - '0');
+
+    if (c >= 'A' && c <= 'F')
+        return (unsigned char)(10 + (c - 'A'));
+
+    return (unsigned char)(10 + (c - 'a'));
+}
+
+OE_INLINE oe_result_t
+oe_hex_to_buf(const char* str, size_t strsize, uint8_t* buf, size_t bufsize)
+{
+    if (bufsize * 2 < strsize)
+    {
+        return OE_BUFFER_TOO_SMALL;
+    }
+    for (size_t i = 0; i < strsize; i += 2)
+    {
+        unsigned char v =
+            (unsigned char)(16 * oe_hex_digit_to_num(str[i]) + oe_hex_digit_to_num(str[i + 1]));
+        buf[i / 2] = v;
+    }
+    return OE_OK;
+}
+
 OE_EXTERNC_END
 
 #endif /* _OE_UTILS_H */
diff --git a/libc/malloc.c b/libc/malloc.c
index 9d9fb25e5..888f06840 100644
--- a/libc/malloc.c
+++ b/libc/malloc.c
@@ -23,3 +23,6 @@
  * musl/src/malloc/lite_malloc.c
  */
 OE_WEAK_ALIAS(malloc, __libc_malloc);
+
+OE_WEAK_ALIAS(free, __libc_free);
+OE_WEAK_ALIAS(calloc, __libc_calloc);
diff --git a/libc/sgx/abort.S b/libc/sgx/abort.S
index 069cb7874..d0a27e531 100644
--- a/libc/sgx/abort.S
+++ b/libc/sgx/abort.S
@@ -6,7 +6,7 @@
 abort:
 .cfi_startproc
 
-    call oe_abort
+    jmp oe_abort  // EDG: was call, but that breaks x64 stack alignment
     ud2
 
 .cfi_endproc
diff --git a/pkgconfig/CMakeLists.txt b/pkgconfig/CMakeLists.txt
index ae0663d31..02cb0ed26 100644
--- a/pkgconfig/CMakeLists.txt
+++ b/pkgconfig/CMakeLists.txt
@@ -89,7 +89,7 @@ set(ENCLAVE_OPENSSL_CRYPTO_WRAPPER_LIBS -loecryptoopenssl -lopensslssl
 set(ENCLAVE_OPENSSL_SYMCRYPT_FIPS_WRAPPER_LIBS
     -loesymcryptengine -loecryptoopenssl -lopensslssl -lopensslcrypto)
 
-set(ENCLAVE_CLIBS_2 -loelibc -loesyscall -loecore)
+set(ENCLAVE_CLIBS_2 -loelibc -loesyscall -loelibc -loecore)
 
 set(ENCLAVE_CLIBS_LIST ${ENCLAVE_CLIBS_1} ${ENCLAVE_CLIBS_2})
 list(JOIN ENCLAVE_CLIBS_LIST " " ENCLAVE_CLIBS)
diff --git a/samples/attested_tls/client/enc/Makefile b/samples/attested_tls/client/enc/Makefile
index be66af8d1..1e0e7501b 100644
--- a/samples/attested_tls/client/enc/Makefile
+++ b/samples/attested_tls/client/enc/Makefile
@@ -40,7 +40,7 @@ build:
 
 	$(CXX) -g -c $(CXXFLAGS) $(INCLUDES) -I. -std=c++11 $(SRC_FILES)
 	$(CC) -c $(CFLAGS) $(CINCLUDES) -I. ./tls_client_t.c
-	$(CXX) -o tls_client_enc $(OBJ_FILES) $(LDFLAGS) $(CRYPTO_LDFLAGS) -loehostsock -loehostresolver
+	$(CXX) -o tls_client_enc $(OBJ_FILES) $(LDFLAGS) $(CRYPTO_LDFLAGS) -loehostsock -loehostresolver -loecore
 
 sign:
 	oesign sign -e tls_client_enc -c  enc.conf -k private.pem
diff --git a/samples/attested_tls/server/enc/Makefile b/samples/attested_tls/server/enc/Makefile
index f93de6a1b..44f35d565 100644
--- a/samples/attested_tls/server/enc/Makefile
+++ b/samples/attested_tls/server/enc/Makefile
@@ -42,7 +42,7 @@ build:
 
 	$(CXX) -g -c $(CXXFLAGS) $(INCLUDES) -I. -std=c++11 ${SRC_FILES}
 	$(CC) -c $(CFLAGS) $(CINCLUDES) -I. tls_server_t.c
-	$(CXX) -o tls_server_enc $(OBJ_FILES) $(LDFLAGS) $(CRYPTO_LDFLAGS) -loehostsock -loehostresolver
+	$(CXX) -o tls_server_enc $(OBJ_FILES) $(LDFLAGS) $(CRYPTO_LDFLAGS) -loehostsock -loehostresolver -loecore
 
 sign:
 	oesign sign -e tls_server_enc -c enc.conf -k private.pem
diff --git a/samples/debugmalloc/host/Makefile b/samples/debugmalloc/host/Makefile
index 7ea4266a4..b18a70159 100644
--- a/samples/debugmalloc/host/Makefile
+++ b/samples/debugmalloc/host/Makefile
@@ -14,7 +14,7 @@ build:
 		--search-path $(INCDIR)/openenclave/edl/sgx
 	$(CC) -g -c $(CFLAGS) host.c
 	$(CC) -g -c $(CFLAGS) debugmalloc_u.c
-	$(CC) -o debugmallochost debugmalloc_u.o host.o $(LDFLAGS)
+	$(CXX) -o debugmallochost debugmalloc_u.o host.o $(LDFLAGS)
 
 clean:
 	rm -f debugmallochost host.o debugmalloc_u.o debugmalloc_u.c debugmalloc_u.h debugmalloc_args.h
diff --git a/samples/helloworld/host/Makefile b/samples/helloworld/host/Makefile
index 7b3c2c2ec..29bcd0c44 100644
--- a/samples/helloworld/host/Makefile
+++ b/samples/helloworld/host/Makefile
@@ -14,7 +14,7 @@ build:
 		--search-path $(INCDIR)/openenclave/edl/sgx
 	$(CC) -g -c $(CFLAGS) host.c
 	$(CC) -g -c $(CFLAGS) helloworld_u.c
-	$(CC) -o helloworldhost helloworld_u.o host.o $(LDFLAGS)
+	$(CXX) -o helloworldhost helloworld_u.o host.o $(LDFLAGS)
 
 clean:
 	rm -f helloworldhost host.o helloworld_u.o helloworld_u.c helloworld_u.h helloworld_args.h
diff --git a/samples/log_callback/host/Makefile b/samples/log_callback/host/Makefile
index 3725ed9cc..4b3bdd695 100644
--- a/samples/log_callback/host/Makefile
+++ b/samples/log_callback/host/Makefile
@@ -14,7 +14,7 @@ build:
 		--search-path $(INCDIR)/openenclave/edl/sgx
 	$(CC) -g -c $(CFLAGS) host.c
 	$(CC) -g -c $(CFLAGS) log_callback_u.c
-	$(CC) -o log_callbackhost log_callback_u.o host.o $(LDFLAGS)
+	$(CXX) -o log_callbackhost log_callback_u.o host.o $(LDFLAGS)
 
 clean:
 	rm -f log_callbackhost host.o log_callback_u.o log_callback_u.c log_callback_u.h log_callback_args.h
diff --git a/samples/switchless/host/Makefile b/samples/switchless/host/Makefile
index 234aa640b..5e8043871 100644
--- a/samples/switchless/host/Makefile
+++ b/samples/switchless/host/Makefile
@@ -14,7 +14,7 @@ build:
 		--search-path $(INCDIR)/openenclave/edl/sgx
 	$(CC) -g -c $(CFLAGS) host.c
 	$(CC) -g -c $(CFLAGS) switchless_sample_u.c
-	$(CC) -o switchlesshost switchless_sample_u.o host.o $(LDFLAGS)
+	$(CXX) -o switchlesshost switchless_sample_u.o host.o $(LDFLAGS)
 
 clean:
 	rm -f switchlesshost host.o switchless_sample_u.o \
diff --git a/samples/test-samples.cmake b/samples/test-samples.cmake
index b44cab12d..07928cd42 100644
--- a/samples/test-samples.cmake
+++ b/samples/test-samples.cmake
@@ -75,20 +75,14 @@ else ()
         APPEND
         SAMPLES_LIST
         attested_tls
-        attested_tls
-        attested_tls
         attestation
-        file-encryptor
         file-encryptor)
       list(
         APPEND
         CRYPTO_LIB_LIST
         mbedtls
-        openssl
-        openssl_symcrypt_fips
-        mbedtls
         mbedtls
-        openssl)
+        mbedtls)
     endif ()
   endif ()
 endif ()
diff --git a/syscall/CMakeLists.txt b/syscall/CMakeLists.txt
index 17866f5b6..d9747109e 100644
--- a/syscall/CMakeLists.txt
+++ b/syscall/CMakeLists.txt
@@ -66,7 +66,7 @@ enclave_include_directories(
   oesyscall PRIVATE ${CMAKE_CURRENT_SOURCE_DIR} ${CMAKE_CURRENT_BINARY_DIR}
   ${PROJECT_SOURCE_DIR}/include/openenclave/corelibc)
 
-enclave_link_libraries(oesyscall PUBLIC oecore)
+enclave_link_libraries(oesyscall PUBLIC oecore PRIVATE oelibc)
 enclave_compile_options(oesyscall PRIVATE -ffunction-sections)
 
 set_source_files_properties(${CMAKE_CURRENT_BINARY_DIR}/syscall_t.c
diff --git a/syscall/device.c b/syscall/device.c
index 1cb00423c..63664a178 100644
--- a/syscall/device.c
+++ b/syscall/device.c
@@ -270,6 +270,12 @@ done:
     return ret;
 }
 
+uint64_t oe_device_table_get_custom_devid(void)
+{
+    static uint64_t id;
+    return OE_DEVID_CUSTOM + __atomic_fetch_add(&id, 1, __ATOMIC_SEQ_CST);
+}
+
 /*
 **==============================================================================
 **
diff --git a/syscall/devices/hostfs/hostfs.c b/syscall/devices/hostfs/hostfs.c
index b86f2ab10..ae15812c6 100644
--- a/syscall/devices/hostfs/hostfs.c
+++ b/syscall/devices/hostfs/hostfs.c
@@ -21,6 +21,7 @@
 #include <openenclave/enclave.h>
 // clang-format on
 
+#include <openenclave/internal/ert/hostfs.h>
 #include <openenclave/internal/syscall/device.h>
 #include <openenclave/internal/thread.h>
 #include <openenclave/internal/syscall/dirent.h>
@@ -38,33 +39,9 @@
 
 #include "syscall_t.h"
 
-#define FS_MAGIC 0x5f35f964
 #define FILE_MAGIC 0xfe48c6ff
 #define DIR_MAGIC 0x8add1b0b
 
-/* Mask to extract the access mode: O_RDONLY, O_WRONLY, O_RDWR. */
-#define ACCESS_MODE_MASK 000000003
-
-/* The host file system device. */
-typedef struct _device
-{
-    oe_device_t base;
-
-    /* Must be FS_MAGIC. */
-    uint32_t magic;
-
-    /* True if this file system has been mounted. */
-    bool is_mounted;
-
-    /* The parameters that were passed to the mount() function. */
-    struct
-    {
-        unsigned long flags;
-        char source[OE_PATH_MAX];
-        char target[OE_PATH_MAX];
-    } mount;
-} device_t;
-
 /* Create by open(). */
 typedef struct _file
 {
@@ -156,7 +133,7 @@ done:
 }
 
 /* Expand an enclave path to a host path. */
-static int _make_host_path(
+int _hostfs_make_host_path(
     const device_t* fs,
     const char* enclave_path,
     char host_path[OE_PATH_MAX])
@@ -191,7 +168,7 @@ done:
 }
 
 /* Called by oe_mount(). */
-static int _hostfs_mount(
+int _hostfs_mount(
     oe_device_t* device,
     const char* source,
     const char* target,
@@ -211,7 +188,8 @@ static int _hostfs_mount(
         OE_RAISE_ERRNO(OE_EBUSY);
 
     /* Cross check the file system type. */
-    if (oe_strcmp(filesystemtype, OE_DEVICE_NAME_HOST_FILE_SYSTEM) != 0)
+    if (oe_strcmp(filesystemtype, OE_DEVICE_NAME_HOST_FILE_SYSTEM) != 0 &&
+        oe_strcmp(filesystemtype, OE_HOST_FILE_SYSTEM_MMAP) != 0)
         OE_RAISE_ERRNO(OE_EINVAL);
 
     /* The data parameter is not supported for host file systems. */
@@ -247,7 +225,7 @@ done:
 }
 
 /* Called by oe_umount2(). */
-static int _hostfs_umount2(oe_device_t* device, const char* target, int flags)
+int _hostfs_umount2(oe_device_t* device, const char* target, int flags)
 {
     int ret = -1;
     device_t* fs = _cast_device(device);
@@ -279,7 +257,7 @@ done:
 }
 
 /* Called by oe_mount() to make a copy of this device. */
-static int _hostfs_clone(oe_device_t* device, oe_device_t** new_device)
+int _hostfs_clone(oe_device_t* device, oe_device_t** new_device)
 {
     int ret = -1;
     device_t* fs = _cast_device(device);
@@ -301,7 +279,7 @@ done:
 }
 
 /* Called by oe_umount() to release this device. */
-static int _hostfs_release(oe_device_t* device)
+int _hostfs_release(oe_device_t* device)
 {
     int ret = -1;
     device_t* fs = _cast_device(device);
@@ -316,6 +294,7 @@ done:
     return ret;
 }
 
+#if 0
 static oe_fd_t* _hostfs_open_file(
     oe_device_t* device,
     const char* pathname,
@@ -348,7 +327,7 @@ static oe_fd_t* _hostfs_open_file(
 
     /* Ask the host to open the file. */
     {
-        if (_make_host_path(fs, pathname, host_path) != 0)
+        if (_hostfs_make_host_path(fs, pathname, host_path) != 0)
             OE_RAISE_ERRNO_MSG(oe_errno, "pathname=%s", pathname);
 
         if (oe_syscall_open_ocall(&retval, host_path, flags, mode) != OE_OK)
@@ -370,8 +349,9 @@ done:
 
     return ret;
 }
+#endif
 
-static oe_fd_t* _hostfs_open_directory(
+oe_fd_t* _hostfs_open_directory(
     oe_device_t* device,
     const char* pathname,
     int flags)
@@ -421,20 +401,69 @@ done:
 }
 
 static oe_fd_t* _hostfs_open(
-    oe_device_t* fs,
+    oe_device_t* device,
     const char* pathname,
     int flags,
     oe_mode_t mode)
 {
-    if ((flags & OE_O_DIRECTORY))
-    {
-        /* Only existing directories can be opened, so mode is ignored. */
-        return _hostfs_open_directory(fs, pathname, flags);
-    }
-    else
+    // EDG: changed to support:
+    // - open directories without O_DIRECTORY flag
+    // - get fd also for dirs to be able to flock/fsync/... on dirs
+
+    const device_t* const fs = _cast_device(device);
+    file_t* file = NULL;
+
+    /* Fail if any required parameters are null. */
+    if (!fs || !pathname)
+        OE_RAISE_ERRNO(OE_EINVAL);
+
+    /* Fail if attempting to write to a read-only file system. */
+    if (_is_read_only(fs) && (flags & ACCESS_MODE_MASK) != OE_O_RDONLY)
+        OE_RAISE_ERRNO(OE_EPERM);
+
+    char host_path[OE_PATH_MAX];
+    if (_hostfs_make_host_path(fs, pathname, host_path) != 0)
+        OE_RAISE_ERRNO_MSG(oe_errno, "pathname=%s", pathname);
+
+    file = oe_calloc(1, sizeof(file_t));
+    if (!file)
+        OE_RAISE_ERRNO(OE_ENOMEM);
+
+    /* Ask the host to open the file. */
+    oe_host_fd_t fd = -1;
+    uint64_t dir = 0;
+    if (oe_syscall_open_ocall(&fd, host_path, flags, mode, &dir) != OE_OK)
+        OE_RAISE_ERRNO(OE_EINVAL);
+    if (fd < 0)
+        goto done;
+
+    file->host_fd = fd;
+    file->base.type = OE_FD_TYPE_FILE;
+    file->magic = FILE_MAGIC;
+    file->base.ops.file = _get_file_ops();
+
+    if (!dir)
+        return &file->base;
+
+    /* Allocate and initialize the dir struct. */
+
+    dir_t* const di = oe_calloc(1, sizeof(dir_t));
+    if (!di)
     {
-        return _hostfs_open_file(fs, pathname, flags, mode);
+        int retval;
+        oe_syscall_closedir_ocall(&retval, dir);
+        OE_RAISE_ERRNO(OE_ENOMEM);
     }
+
+    di->host_dir = dir;
+    di->magic = DIR_MAGIC;
+    file->dir = &di->base;
+
+    return &file->base;
+
+done:
+    oe_free(file);
+    return NULL;
 }
 
 static int _hostfs_flock(oe_fd_t* desc, int operation)
@@ -1076,7 +1105,7 @@ static oe_fd_t* _hostfs_opendir(oe_device_t* device, const char* name)
     if (!fs || !name)
         OE_RAISE_ERRNO(OE_EINVAL);
 
-    if (_make_host_path(fs, name, host_name) != 0)
+    if (_hostfs_make_host_path(fs, name, host_name) != 0)
         OE_RAISE_ERRNO_MSG(oe_errno, "name=%s", name);
 
     if (!(dir = oe_calloc(1, sizeof(dir_t))))
@@ -1166,7 +1195,7 @@ done:
     return ret;
 }
 
-static int _hostfs_stat(
+int _hostfs_stat(
     oe_device_t* device,
     const char* pathname,
     struct oe_stat_t* buf)
@@ -1182,7 +1211,7 @@ static int _hostfs_stat(
     if (!fs || !pathname || !buf)
         OE_RAISE_ERRNO(OE_EINVAL);
 
-    if (_make_host_path(fs, pathname, host_path) != 0)
+    if (_hostfs_make_host_path(fs, pathname, host_path) != 0)
         OE_RAISE_ERRNO(oe_errno);
 
     if (oe_syscall_stat_ocall(&retval, host_path, buf) != OE_OK)
@@ -1217,7 +1246,7 @@ done:
     return ret;
 }
 
-static int _hostfs_access(oe_device_t* device, const char* pathname, int mode)
+int _hostfs_access(oe_device_t* device, const char* pathname, int mode)
 {
     int ret = -1;
     device_t* fs = _cast_device(device);
@@ -1228,7 +1257,7 @@ static int _hostfs_access(oe_device_t* device, const char* pathname, int mode)
     if (!fs || !pathname || ((uint32_t)mode & ~MASK))
         OE_RAISE_ERRNO(OE_EINVAL);
 
-    if (_make_host_path(fs, pathname, host_path) != 0)
+    if (_hostfs_make_host_path(fs, pathname, host_path) != 0)
         OE_RAISE_ERRNO(oe_errno);
 
     if (oe_syscall_access_ocall(&retval, host_path, mode) != OE_OK)
@@ -1241,10 +1270,7 @@ done:
     return ret;
 }
 
-static int _hostfs_link(
-    oe_device_t* device,
-    const char* oldpath,
-    const char* newpath)
+int _hostfs_link(oe_device_t* device, const char* oldpath, const char* newpath)
 {
     int ret = -1;
     device_t* fs = _cast_device(device);
@@ -1259,10 +1285,10 @@ static int _hostfs_link(
     if (_is_read_only(fs))
         OE_RAISE_ERRNO(OE_EPERM);
 
-    if (_make_host_path(fs, oldpath, host_oldpath) != 0)
+    if (_hostfs_make_host_path(fs, oldpath, host_oldpath) != 0)
         OE_RAISE_ERRNO(oe_errno);
 
-    if (_make_host_path(fs, newpath, host_newpath) != 0)
+    if (_hostfs_make_host_path(fs, newpath, host_newpath) != 0)
         OE_RAISE_ERRNO(oe_errno);
 
     if (oe_syscall_link_ocall(&retval, host_oldpath, host_newpath) != OE_OK)
@@ -1275,7 +1301,7 @@ done:
     return ret;
 }
 
-static int _hostfs_unlink(oe_device_t* device, const char* pathname)
+int _hostfs_unlink(oe_device_t* device, const char* pathname)
 {
     int ret = -1;
     device_t* fs = _cast_device(device);
@@ -1289,7 +1315,7 @@ static int _hostfs_unlink(oe_device_t* device, const char* pathname)
     if (_is_read_only(fs))
         OE_RAISE_ERRNO(OE_EPERM);
 
-    if (_make_host_path(fs, pathname, host_path) != 0)
+    if (_hostfs_make_host_path(fs, pathname, host_path) != 0)
         OE_RAISE_ERRNO(oe_errno);
 
     if (oe_syscall_unlink_ocall(&retval, host_path) != OE_OK)
@@ -1302,7 +1328,7 @@ done:
     return ret;
 }
 
-static int _hostfs_rename(
+int _hostfs_rename(
     oe_device_t* device,
     const char* oldpath,
     const char* newpath)
@@ -1319,10 +1345,10 @@ static int _hostfs_rename(
     if (_is_read_only(fs))
         OE_RAISE_ERRNO(OE_EPERM);
 
-    if (_make_host_path(fs, oldpath, host_oldpath) != 0)
+    if (_hostfs_make_host_path(fs, oldpath, host_oldpath) != 0)
         OE_RAISE_ERRNO(oe_errno);
 
-    if (_make_host_path(fs, newpath, host_newpath) != 0)
+    if (_hostfs_make_host_path(fs, newpath, host_newpath) != 0)
         OE_RAISE_ERRNO(oe_errno);
 
     if (oe_syscall_rename_ocall(&retval, host_oldpath, host_newpath) != OE_OK)
@@ -1335,10 +1361,7 @@ done:
     return ret;
 }
 
-static int _hostfs_truncate(
-    oe_device_t* device,
-    const char* path,
-    oe_off_t length)
+int _hostfs_truncate(oe_device_t* device, const char* path, oe_off_t length)
 {
     int ret = -1;
     device_t* fs = _cast_device(device);
@@ -1351,7 +1374,7 @@ static int _hostfs_truncate(
     if (_is_read_only(fs))
         OE_RAISE_ERRNO(OE_EPERM);
 
-    if (_make_host_path(fs, path, host_path) != 0)
+    if (_hostfs_make_host_path(fs, path, host_path) != 0)
         OE_RAISE_ERRNO(oe_errno);
 
     if (oe_syscall_truncate_ocall(&retval, host_path, length) != OE_OK)
@@ -1382,10 +1405,7 @@ done:
     return ret;
 }
 
-static int _hostfs_mkdir(
-    oe_device_t* device,
-    const char* pathname,
-    oe_mode_t mode)
+int _hostfs_mkdir(oe_device_t* device, const char* pathname, oe_mode_t mode)
 {
     int ret = -1;
     device_t* fs = _cast_device(device);
@@ -1399,7 +1419,7 @@ static int _hostfs_mkdir(
     if (_is_read_only(fs))
         OE_RAISE_ERRNO(OE_EPERM);
 
-    if (_make_host_path(fs, pathname, host_path) != 0)
+    if (_hostfs_make_host_path(fs, pathname, host_path) != 0)
         OE_RAISE_ERRNO(oe_errno);
 
     if (oe_syscall_mkdir_ocall(&retval, host_path, mode) != OE_OK)
@@ -1412,7 +1432,7 @@ done:
     return ret;
 }
 
-static int _hostfs_rmdir(oe_device_t* device, const char* pathname)
+int _hostfs_rmdir(oe_device_t* device, const char* pathname)
 {
     int ret = -1;
     device_t* fs = _cast_device(device);
@@ -1426,7 +1446,7 @@ static int _hostfs_rmdir(oe_device_t* device, const char* pathname)
     if (_is_read_only(fs))
         OE_RAISE_ERRNO(OE_EPERM);
 
-    if (_make_host_path(fs, pathname, host_path) != 0)
+    if (_hostfs_make_host_path(fs, pathname, host_path) != 0)
         OE_RAISE_ERRNO(oe_errno);
 
     if (oe_syscall_rmdir_ocall(&retval, host_path) != OE_OK)
@@ -1443,6 +1463,10 @@ static oe_host_fd_t _hostfs_get_host_fd(oe_fd_t* desc)
 {
     file_t* file = _cast_file(desc);
 
+    // EDG: set errno if this is a directory file
+    if (file && file->host_fd == -1)
+        oe_errno = OE_EINVAL;
+
     return file ? file->host_fd : -1;
 }
 
@@ -1526,6 +1550,15 @@ oe_result_t oe_load_module_host_file_system(void)
             OE_RAISE(OE_FAILURE);
         }
 
+        if (oe_device_table_set(
+                OE_DEVID_HOST_FILE_SYSTEM_MMAP, &oe_hostfs_mmap.base) != 0)
+        {
+            oe_device_table_remove(OE_DEVID_HOST_FILE_SYSTEM);
+            /* Do not propagate errno to caller. */
+            oe_errno = 0;
+            OE_RAISE(OE_FAILURE);
+        }
+
         _loaded = true;
     }
 
diff --git a/syscall/devices/hostsock/hostsock.c b/syscall/devices/hostsock/hostsock.c
index 9f2a6f51e..ef6be069e 100644
--- a/syscall/devices/hostsock/hostsock.c
+++ b/syscall/devices/hostsock/hostsock.c
@@ -20,6 +20,7 @@
 #include <openenclave/corelibc/stdlib.h>
 #include <openenclave/internal/raise.h>
 #include <openenclave/internal/safecrt.h>
+#include <openenclave/internal/ert/sock.h>
 #include "syscall_t.h"
 
 #define DEVICE_MAGIC 0x536f636b
@@ -34,13 +35,6 @@ typedef struct _device
     oe_host_fd_t host_fd;
 } device_t;
 
-typedef struct _sock
-{
-    oe_fd_t base;
-    uint32_t magic;
-    oe_host_fd_t host_fd;
-} sock_t;
-
 static sock_t* _new_sock(void)
 {
     sock_t* sock = NULL;
@@ -56,6 +50,11 @@ static sock_t* _new_sock(void)
     return sock;
 }
 
+sock_t* oe_hostsock_new_sock(void)
+{
+    return _new_sock();
+}
+
 static device_t* _cast_device(const oe_device_t* device)
 {
     device_t* p = (device_t*)device;
@@ -100,6 +99,8 @@ static oe_fd_t* _hostsock_device_socket(
     if (!(new_sock = _new_sock()))
         OE_RAISE_ERRNO(OE_ENOMEM);
 
+    // TODO Do not create host socket here, but in bind or connect.
+
     /* Call the host. */
     {
         oe_host_fd_t retval = -1;
@@ -114,6 +115,11 @@ static oe_fd_t* _hostsock_device_socket(
     }
 
     ret = &new_sock->base;
+
+    // EDG: remember flag for internal socket
+    if (type & SOCK_NONBLOCK)
+        new_sock->internal.flags = OE_O_NONBLOCK;
+
     new_sock = NULL;
 
 done:
@@ -210,6 +216,13 @@ static int _hostsock_connect(
     if (oe_memcpy_s(&buf, sizeof(buf), addr, addrlen) != OE_OK)
         OE_RAISE_ERRNO(OE_EINVAL);
 
+    // EDG: try internal first
+    const oe_result_t internal = oe_internalsock_connect(sock, addr);
+    if (internal == OE_OK)
+        return 0;
+    if (internal != OE_NOT_FOUND)
+        OE_RAISE_ERRNO(oe_errno);
+
     /* Call host. */
     if (oe_syscall_connect_ocall(&ret, sock->host_fd, &buf.addr, addrlen) !=
         OE_OK)
@@ -312,6 +325,13 @@ static int _hostsock_bind(
     if (oe_memcpy_s(&buf, sizeof(buf), addr, addrlen) != OE_OK)
         OE_RAISE_ERRNO(OE_EINVAL);
 
+    // EDG: try internal first
+    const oe_result_t internal = oe_internalsock_bind(sock, addr);
+    if (internal == OE_OK)
+        return 0;
+    if (internal != OE_NOT_FOUND)
+        OE_RAISE_ERRNO(oe_errno);
+
     /* Call the host. */
     if (oe_syscall_bind_ocall(&ret, sock->host_fd, &buf.addr, addrlen) != OE_OK)
         OE_RAISE_ERRNO(OE_EINVAL);
diff --git a/syscall/hostcalls.c b/syscall/hostcalls.c
index f2939fdd0..b38c05fc5 100644
--- a/syscall/hostcalls.c
+++ b/syscall/hostcalls.c
@@ -129,7 +129,8 @@ oe_result_t _oe_syscall_open_ocall(
     oe_host_fd_t* _retval,
     const char* pathname,
     int flags,
-    oe_mode_t mode);
+    oe_mode_t mode,
+    uint64_t* dir);
 oe_result_t _oe_syscall_read_ocall(
     ssize_t* _retval,
     oe_host_fd_t fd,
@@ -229,12 +230,14 @@ oe_result_t _oe_syscall_open_ocall(
     oe_host_fd_t* _retval,
     const char* pathname,
     int flags,
-    oe_mode_t mode)
+    oe_mode_t mode,
+    uint64_t* dir)
 {
     OE_UNUSED(_retval);
     OE_UNUSED(pathname);
     OE_UNUSED(flags);
     OE_UNUSED(mode);
+    OE_UNUSED(dir);
     return OE_UNSUPPORTED;
 }
 OE_WEAK_ALIAS(_oe_syscall_open_ocall, oe_syscall_open_ocall);
diff --git a/syscall/mount.c b/syscall/mount.c
index 6de079f60..07e1e1c32 100644
--- a/syscall/mount.c
+++ b/syscall/mount.c
@@ -160,6 +160,9 @@ int oe_mount(
     if (!device)
         OE_RAISE_ERRNO_MSG(OE_ENODEV, "filesystemtype=%s", filesystemtype);
 
+// EDG: disabled because we want to be able to mount anywhere without simulating
+// a complete root fs.
+#if 0
     /* Be sure the full_target directory exists (if not root). */
     if (oe_strcmp(target, "/") != 0)
     {
@@ -177,6 +180,7 @@ int oe_mount(
         if (!OE_S_ISDIR(buf.st_mode))
             OE_RAISE_ERRNO(OE_ENOTDIR);
     }
+#endif
 
     /* Lock the mount table. */
     oe_spin_lock(&_lock);
diff --git a/syscall/netdb.c b/syscall/netdb.c
index 26d943fdb..2edcb473a 100644
--- a/syscall/netdb.c
+++ b/syscall/netdb.c
@@ -2,6 +2,8 @@
 // Licensed under the MIT License.
 
 #include <openenclave/corelibc/stdlib.h>
+#include <openenclave/corelibc/string.h>
+#include <openenclave/internal/syscall/arpa/inet.h>
 #include <openenclave/internal/syscall/netdb.h>
 #include <openenclave/internal/syscall/raise.h>
 #include <openenclave/internal/syscall/resolver.h>
@@ -57,6 +59,360 @@ done:
     return ret;
 }
 
+#define OE_IN6_IS_ADDR_MULTICAST(a) (((uint8_t*)(a))[0] == 0xff)
+#define OE_IN6_IS_ADDR_LINKLOCAL(a) \
+    ((((uint8_t*)(a))[0]) == 0xfe && (((uint8_t*)(a))[1] & 0xc0) == 0x80)
+#define OE_IN6_IS_ADDR_MC_LINKLOCAL(a) \
+    (OE_IN6_IS_ADDR_MULTICAST(a) && ((((uint8_t*)(a))[1] & 0xf) == 0x2))
+
+// copied from musl/network/lookup.h
+struct address
+{
+    int family;
+    unsigned scopeid;
+    uint8_t addr[16];
+    int sortkey;
+};
+struct service
+{
+    uint16_t port;
+    unsigned char proto, socktype;
+};
+
+// copied from musl/network/lookup_name.c
+static int name_from_null(
+    struct address buf[static 2],
+    const char* name,
+    int family,
+    int flags)
+{
+    int cnt = 0;
+    if (name)
+        return 0;
+    if (flags & OE_AI_PASSIVE)
+    {
+        if (family != OE_AF_INET6)
+            buf[cnt++] = (struct address){.family = OE_AF_INET};
+        if (family != OE_AF_INET)
+            buf[cnt++] = (struct address){.family = OE_AF_INET6};
+    }
+    else
+    {
+        if (family != OE_AF_INET6)
+            buf[cnt++] =
+                (struct address){.family = OE_AF_INET, .addr = {127, 0, 0, 1}};
+        if (family != OE_AF_INET)
+            buf[cnt++] =
+                (struct address){.family = OE_AF_INET6, .addr = {[15] = 1}};
+    }
+    return cnt;
+}
+
+// adapted from musl/network/lookup_name.c
+// - Do not try to look up name in /etc/hosts and fail with OE_EAI_FAIL if the
+// name cannot be resolved internally.
+// - Do not sort results because it would require host calls.
+static int _lookup_name(
+    struct address buf[static 2],
+    char canon[static 256],
+    const char* name,
+    int family,
+    int flags)
+{
+    size_t strnlen(const char*, size_t);
+    int __lookup_ipliteral(
+        struct address buf[static 1], const char* name, int family);
+
+    int cnt = 0, i, j;
+
+    *canon = 0;
+    if (name)
+    {
+        /* reject empty name and check len so it fits into temp bufs */
+        size_t l = strnlen(name, 255);
+        if (l - 1 >= 254)
+            return OE_EAI_NONAME;
+        memcpy(canon, name, l + 1);
+    }
+
+    /* Procedurally, a request for v6 addresses with the v4-mapped
+     * flag set is like a request for unspecified family, followed
+     * by filtering of the results. */
+    if (flags & OE_AI_V4MAPPED)
+    {
+        if (family == OE_AF_INET6)
+            family = OE_AF_UNSPEC;
+        else
+            flags -= OE_AI_V4MAPPED;
+    }
+
+    /* Try each backend until there's at least one result. */
+    cnt = name_from_null(buf, name, family, flags);
+    if (!cnt)
+        cnt = __lookup_ipliteral(buf, name, family);
+    if (!cnt && !(flags & OE_AI_NUMERICHOST))
+    {
+        if (oe_strcmp(name, "localhost") == 0)
+            cnt = name_from_null(buf, NULL, family, 0);
+        if (!cnt)
+            // EDG: cannot be resolved internally (do not try /etc/hosts)
+            return OE_EAI_FAIL;
+    }
+    if (cnt <= 0)
+        return cnt ? cnt : OE_EAI_NONAME;
+
+    /* Filter/transform results for v4-mapped lookup, if requested. */
+    if (flags & OE_AI_V4MAPPED)
+    {
+        if (!(flags & OE_AI_ALL))
+        {
+            /* If any v6 results exist, remove v4 results. */
+            for (i = 0; i < cnt && buf[i].family != OE_AF_INET6; i++)
+                ;
+            if (i < cnt)
+            {
+                for (j = 0; i < cnt; i++)
+                {
+                    if (buf[i].family == OE_AF_INET6)
+                        buf[j++] = buf[i];
+                }
+                cnt = i = j;
+            }
+        }
+        /* Translate any remaining v4 results to v6 */
+        for (i = 0; i < cnt; i++)
+        {
+            if (buf[i].family != OE_AF_INET)
+                continue;
+            memcpy(buf[i].addr + 12, buf[i].addr, 4);
+            memcpy(buf[i].addr, "\0\0\0\0\0\0\0\0\0\0\xff\xff", 12);
+            buf[i].family = OE_AF_INET6;
+        }
+    }
+
+    return cnt;
+}
+
+// adapted from musl/network/lookup_serv.c
+// - do not try to look up name in /etc/services
+static int _lookup_serv(
+    struct service buf[static 2],
+    const char* name,
+    int proto,
+    int socktype,
+    int flags)
+{
+    int cnt = 0;
+    char* z = "";
+    unsigned long port = 0;
+
+    switch (socktype)
+    {
+        case OE_SOCK_STREAM:
+            switch (proto)
+            {
+                case 0:
+                    proto = IPPROTO_TCP;
+                case IPPROTO_TCP:
+                    break;
+                default:
+                    return OE_EAI_SERVICE;
+            }
+            break;
+        case OE_SOCK_DGRAM:
+            switch (proto)
+            {
+                case 0:
+                    proto = IPPROTO_UDP;
+                case IPPROTO_UDP:
+                    break;
+                default:
+                    return OE_EAI_SERVICE;
+            }
+        case 0:
+            break;
+        default:
+            if (name)
+                return OE_EAI_SERVICE;
+            buf[0].port = 0;
+            buf[0].proto = (unsigned char)proto;
+            buf[0].socktype = (unsigned char)socktype;
+            return 1;
+    }
+
+    if (name)
+    {
+        if (!*name)
+            return OE_EAI_SERVICE;
+        port = oe_strtoul(name, &z, 10);
+    }
+    if (!*z)
+    {
+        if (port > 65535)
+            return OE_EAI_SERVICE;
+        if (proto != IPPROTO_UDP)
+        {
+            buf[cnt].port = (uint16_t)port;
+            buf[cnt].socktype = OE_SOCK_STREAM;
+            buf[cnt++].proto = IPPROTO_TCP;
+        }
+        if (proto != IPPROTO_TCP)
+        {
+            buf[cnt].port = (uint16_t)port;
+            buf[cnt].socktype = OE_SOCK_DGRAM;
+            buf[cnt++].proto = IPPROTO_UDP;
+        }
+        return cnt;
+    }
+
+    if (flags & OE_AI_NUMERICSERV)
+        return OE_EAI_NONAME;
+
+    return OE_EAI_SERVICE;
+}
+
+// adapted from musl/network/getaddrinfo.c
+// This function fails with OE_EAI_FAIL if the name cannot be resolved
+// internally, i.e., is not an IP address. In this case the request may be
+// forwarded to the host. On other errors the request must not be forwarded to
+// the host. Consider these examples:
+// 255.0.0.1:80 succeeds.
+// myhost:80 fails with OE_EAI_FAIL and may be resolved by the host.
+// myhost:http fails with OE_EAI_FAIL and may be resolved by the host.
+// 255.0.0.1:http fails with OE_EAI_SERVICE and must not be resolved by the host
+// because it could return another IP address. We could add additional logic if
+// we ever need to resolve this combination of host/service.
+static int _getaddrinfo(
+    const char* restrict host,
+    const char* restrict serv,
+    const struct oe_addrinfo* restrict hint,
+    struct oe_addrinfo** restrict res)
+{
+    struct service ports[2];
+    struct address addrs[2];
+    char canon[256];
+    int nservs, naddrs, i, j;
+    int family = OE_AF_UNSPEC, flags = 0, proto = 0, socktype = 0;
+
+    if (!host && !serv)
+        return OE_EAI_NONAME;
+
+    if (hint)
+    {
+        family = hint->ai_family;
+        flags = hint->ai_flags;
+        proto = hint->ai_protocol;
+        socktype = hint->ai_socktype;
+
+        const int mask = OE_AI_PASSIVE | OE_AI_CANONNAME | OE_AI_NUMERICHOST |
+                         OE_AI_V4MAPPED | OE_AI_ALL | OE_AI_ADDRCONFIG |
+                         OE_AI_NUMERICSERV;
+        if ((flags & mask) != flags)
+            return OE_EAI_BADFLAGS;
+
+        switch (family)
+        {
+            case OE_AF_INET:
+            case OE_AF_INET6:
+            case OE_AF_UNSPEC:
+                break;
+            default:
+                return OE_EAI_FAMILY;
+        }
+    }
+
+    // EDG: Ignore AI_ADDRCONFIG flag because it would require to create a host
+    // socket.
+
+    // EDG: Look up name first so that something like myhost:http fails with
+    // OE_EAI_FAIL instead of OE_EAI_SERVICE and, thus, will be forwarded to the
+    // host.
+    naddrs = _lookup_name(addrs, canon, host, family, flags);
+    if (naddrs < 0)
+        return naddrs;
+
+    nservs = _lookup_serv(ports, serv, proto, socktype, flags);
+    if (nservs < 0)
+        return nservs;
+
+    // EDG: Memory allocation for the result differs from the musl
+    // implementation such that it is compatible with the oe_freeaddrinfo
+    // implementation.
+
+    const size_t canon_len = oe_strlen(canon);
+
+    struct oe_addrinfo* head = NULL;
+    struct oe_addrinfo** next = &head;
+
+    for (i = 0; i < naddrs; i++)
+        for (j = 0; j < nservs; j++)
+        {
+            struct oe_addrinfo* const ai = oe_malloc(sizeof *ai);
+            if (!ai)
+            {
+                oe_freeaddrinfo(head);
+                return OE_EAI_MEMORY;
+            }
+            *next = ai;
+            next = &ai->ai_next;
+
+            *ai = (struct oe_addrinfo){
+                .ai_family = addrs[i].family,
+                .ai_socktype = ports[j].socktype,
+                .ai_protocol = ports[j].proto,
+                .ai_addrlen = addrs[i].family == OE_AF_INET
+                                  ? sizeof(struct oe_sockaddr_in)
+                                  : sizeof(struct oe_sockaddr_in6),
+                .ai_addr = NULL,
+                .ai_canonname = NULL,
+                .ai_next = NULL};
+
+            ai->ai_addr = oe_calloc(1, ai->ai_addrlen);
+            if (!ai->ai_addr)
+            {
+                oe_freeaddrinfo(head);
+                return OE_EAI_MEMORY;
+            }
+
+            switch (addrs[i].family)
+            {
+                case OE_AF_INET:
+                {
+                    struct oe_sockaddr_in* const sin =
+                        (struct oe_sockaddr_in*)ai->ai_addr;
+                    sin->sin_family = OE_AF_INET;
+                    sin->sin_port = oe_htons(ports[j].port);
+                    memcpy(&sin->sin_addr, &addrs[i].addr, 4);
+                }
+                break;
+                case OE_AF_INET6:
+                {
+                    struct oe_sockaddr_in6* const sin6 =
+                        (struct oe_sockaddr_in6*)ai->ai_addr;
+                    sin6->sin6_family = OE_AF_INET6;
+                    sin6->sin6_port = oe_htons(ports[j].port);
+                    sin6->sin6_scope_id = addrs[i].scopeid;
+                    memcpy(&sin6->sin6_addr, &addrs[i].addr, 16);
+                }
+                break;
+            }
+
+            if (canon_len)
+            {
+                char* const cn = oe_malloc(canon_len + 1);
+                if (!cn)
+                {
+                    oe_freeaddrinfo(head);
+                    return OE_EAI_MEMORY;
+                }
+                memcpy(cn, canon, canon_len + 1);
+                ai->ai_canonname = cn;
+            }
+        }
+    *res = head;
+    return 0;
+}
+
 int oe_getaddrinfo(
     const char* node,
     const char* service,
@@ -72,6 +428,12 @@ int oe_getaddrinfo(
     else
         OE_RAISE_ERRNO(OE_EINVAL);
 
+    // EDG: Try to resolve internally. This is important for internal sockets
+    // because the host could otherwise hijack them.
+    const int ret_getaddrinfo = _getaddrinfo(node, service, hints, res_out);
+    if (ret_getaddrinfo != OE_EAI_FAIL)
+        return ret_getaddrinfo;
+
     oe_spin_lock(&_lock);
     locked = true;
 
@@ -94,6 +456,131 @@ done:
     return ret;
 }
 
+// copied from musl/src/getnameinfo.c
+static char* itoa(char* p, unsigned x)
+{
+    p += 3 * sizeof(int);
+    *--p = 0;
+    do
+    {
+        *--p = (char)('0' + x % 10);
+        x /= 10;
+    } while (x);
+    return p;
+}
+
+// copied from musl/src/getnameinfo.c
+static void mkptr4(char* s, const unsigned char* ip)
+{
+    int sprintf();
+    sprintf(s, "%d.%d.%d.%d.in-addr.arpa", ip[3], ip[2], ip[1], ip[0]);
+}
+
+// copied from musl/src/getnameinfo.c
+static void mkptr6(char* s, const unsigned char* ip)
+{
+    static const char xdigits[] = "0123456789abcdef";
+    int i;
+    for (i = 15; i >= 0; i--)
+    {
+        *s++ = xdigits[ip[i] & 15];
+        *s++ = '.';
+        *s++ = xdigits[ip[i] >> 4];
+        *s++ = '.';
+    }
+    char* strcpy(char*, const char*);
+    strcpy(s, "ip6.arpa");
+}
+
+#define IF_NAMESIZE 16
+
+// adapted from musl/src/getnameinfo.c
+// do not try hosts/services file or DNS
+static int _getnameinfo(
+    const struct oe_sockaddr* restrict sa,
+    oe_socklen_t sl,
+    char* restrict node,
+    oe_socklen_t nodelen,
+    char* restrict serv,
+    oe_socklen_t servlen,
+    int flags)
+{
+    char* strcpy(char*, const char*);
+    char* strcat(char*, const char*);
+    const char* inet_ntop(int, const void*, char*, oe_socklen_t);
+    char* if_indextoname(unsigned int, char*);
+
+    const size_t PTR_MAX = 64 + sizeof ".in-addr.arpa";
+
+    char ptr[PTR_MAX];
+    char buf[256], num[3 * sizeof(int) + 1];
+    int af = sa->sa_family;
+    unsigned char* a;
+    unsigned scopeid;
+
+    switch (af)
+    {
+        case OE_AF_INET:
+            a = (void*)&((struct oe_sockaddr_in*)sa)->sin_addr;
+            if (sl < sizeof(struct oe_sockaddr_in))
+                return OE_EAI_FAMILY;
+            mkptr4(ptr, a);
+            scopeid = 0;
+            break;
+        case OE_AF_INET6:
+            a = (void*)&((struct oe_sockaddr_in6*)sa)->sin6_addr;
+            if (sl < sizeof(struct oe_sockaddr_in6))
+                return OE_EAI_FAMILY;
+            if (memcmp(a, "\0\0\0\0\0\0\0\0\0\0\xff\xff", 12))
+                mkptr6(ptr, a);
+            else
+                mkptr4(ptr, a + 12);
+            scopeid = ((struct oe_sockaddr_in6*)sa)->sin6_scope_id;
+            break;
+        default:
+            return OE_EAI_FAMILY;
+    }
+
+    if (node && nodelen)
+    {
+        buf[0] = 0;
+        {
+            if (flags & OE_NI_NAMEREQD)
+                return OE_EAI_NONAME;
+            inet_ntop(af, a, buf, sizeof buf);
+            if (scopeid)
+            {
+                char *p = 0, tmp[IF_NAMESIZE + 1];
+                if (!(flags & OE_NI_NUMERICSCOPE) &&
+                    (OE_IN6_IS_ADDR_LINKLOCAL(a) ||
+                     OE_IN6_IS_ADDR_MC_LINKLOCAL(a)))
+                    p = if_indextoname(scopeid, tmp + 1);
+                if (!p)
+                    p = itoa(num, scopeid);
+                *--p = '%';
+                strcat(buf, p);
+            }
+        }
+        if (oe_strlen(buf) >= nodelen)
+            return OE_EAI_OVERFLOW;
+        strcpy(node, buf);
+    }
+
+    if (serv && servlen)
+    {
+        char* p = buf;
+        int port = oe_ntohs(((struct oe_sockaddr_in*)sa)->sin_port);
+        buf[0] = 0;
+        if (!*p)
+            p = itoa(num, (unsigned)port);
+        if (oe_strlen(p) >= servlen)
+            return OE_EAI_OVERFLOW;
+        strcpy(serv, p);
+    }
+
+    return 0;
+}
+
 int oe_getnameinfo(
     const struct oe_sockaddr* sa,
     oe_socklen_t salen,
@@ -106,6 +593,12 @@ int oe_getnameinfo(
     ssize_t ret = OE_EAI_FAIL;
     bool locked = false;
 
+    // EDG: Try to resolve internally.
+    const int ret_getnameinfo =
+        _getnameinfo(sa, salen, host, hostlen, serv, servlen, flags);
+    if (ret_getnameinfo != OE_EAI_NONAME)
+        return ret_getnameinfo;
+
     oe_spin_lock(&_lock);
     locked = true;
 
diff --git a/syscall/poll.c b/syscall/poll.c
index 072e4fec5..a70034931 100644
--- a/syscall/poll.c
+++ b/syscall/poll.c
@@ -16,7 +16,9 @@ int oe_poll(struct oe_pollfd* fds, oe_nfds_t nfds, int timeout)
     struct oe_host_pollfd* host_fds = NULL;
     oe_nfds_t i;
 
-    if (!fds || nfds == 0)
+    // EDG: poll with nfds=0 can be used as sleep. (Python uses it this way and
+    // it is also documented in the manpage.)
+    if (!fds) // || nfds == 0)
         OE_RAISE_ERRNO(OE_EINVAL);
 
     if (!(host_fds = oe_calloc(nfds, sizeof(struct oe_host_pollfd))))
diff --git a/syscall/syscall.c b/syscall/syscall.c
index c77f3b87c..b46890514 100644
--- a/syscall/syscall.c
+++ b/syscall/syscall.c
@@ -209,6 +209,15 @@ OE_WEAK OE_DEFINE_SYSCALL4_M(SYS_epoll_wait)
 }
 #endif
 
+OE_WEAK OE_DEFINE_SYSCALL2(SYS_eventfd2)
+{
+    oe_errno = 0;
+    const unsigned int initval = (unsigned int)arg1;
+    const int flags = (int)arg2;
+    int oe_eventfd(unsigned int initval, int flags);
+    return oe_eventfd(initval, flags);
+}
+
 OE_WEAK OE_DEFINE_SYSCALL1(SYS_exit)
 {
     oe_errno = 0;
@@ -1190,6 +1199,7 @@ static long _syscall(
 #if __x86_64__ || _M_X64
         OE_SYSCALL_DISPATCH(SYS_epoll_wait, arg1, arg2, arg3, arg4);
 #endif
+        OE_SYSCALL_DISPATCH(SYS_eventfd2, arg1, arg2);
         OE_SYSCALL_DISPATCH(SYS_exit, arg1);
         OE_SYSCALL_DISPATCH(SYS_exit_group, arg1);
         OE_SYSCALL_DISPATCH(SYS_faccessat, arg1, arg2, arg3, arg4);
diff --git a/syscall/unistd.c b/syscall/unistd.c
index db56a077e..3d9448152 100644
--- a/syscall/unistd.c
+++ b/syscall/unistd.c
@@ -299,6 +299,23 @@ done:
     return ret;
 }
 
+int oe_close_hostfd(oe_host_fd_t fd)
+{
+    int ret = -1;
+    int retval = -1;
+
+    if (oe_syscall_close_ocall(&retval, fd) != OE_OK)
+        OE_RAISE_ERRNO(OE_EINVAL);
+
+    if (retval == -1)
+        OE_RAISE_ERRNO(oe_errno);
+
+    ret = retval;
+
+done:
+    return ret;
+}
+
 int oe_flock(int fd, int operation)
 {
     int ret = -1;
diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt
index 00a99f144..cb2e4a859 100644
--- a/tests/CMakeLists.txt
+++ b/tests/CMakeLists.txt
@@ -74,7 +74,7 @@ if (OE_SGX)
   add_subdirectory(debugger)
   add_subdirectory(host_verify)
   add_subdirectory(invalid_image)
-  add_subdirectory(config_id)
+  #add_subdirectory(config_id)
   add_subdirectory(switchless)
   add_subdirectory(switchless_atexit_calls)
   add_subdirectory(switchless_threads)
@@ -128,7 +128,7 @@ if (UNIX
     add_subdirectory(custom_claims)
     add_subdirectory(debug-mode)
     add_subdirectory(ecall)
-    add_subdirectory(ecall_conflict)
+    #add_subdirectory(ecall_conflict)
     add_subdirectory(ecall_ocall)
     add_subdirectory(echo)
     add_subdirectory(enclaveparam)
diff --git a/tests/crypto/enclave/enc/enc.c b/tests/crypto/enclave/enc/enc.c
index cfbd81120..862f0d4ea 100644
--- a/tests/crypto/enclave/enc/enc.c
+++ b/tests/crypto/enclave/enc/enc.c
@@ -168,7 +168,7 @@ static long _syscall_dispatch(
         OE_SYSCALL_DISPATCH(SYS_readv, arg1, arg2, arg3);
         OE_SYSCALL_DISPATCH(SYS_close, arg1);
         default:
-            return -1;
+            return -2;
     }
 }
 
@@ -190,7 +190,8 @@ static oe_result_t _syscall_hook(
         OE_RAISE(OE_INVALID_PARAMETER);
 
     *ret = _syscall_dispatch(number, arg1, arg2, arg3, arg4, arg5, arg6);
-    result = OE_OK;
+    if (*ret != -2)
+        result = OE_OK;
 done:
     return result;
 }
diff --git a/tests/debugger/CMakeLists.txt b/tests/debugger/CMakeLists.txt
index 482218255..32aa9dce1 100644
--- a/tests/debugger/CMakeLists.txt
+++ b/tests/debugger/CMakeLists.txt
@@ -23,23 +23,3 @@ add_test(
     --command=${CMAKE_CURRENT_SOURCE_DIR}/commands.gdb
     --return-child-result # This fails the test in case of any error.
     -arg host/db_test_host enc/db_test_enc --simulation-mode)
-
-add_test(
-  NAME oelldb-test
-  COMMAND
-    ${OE_BINDIR}/oelldb -o
-    "command script import ${CMAKE_CURRENT_SOURCE_DIR}/commands.py" -o "quit"
-    -- host/db_test_host enc/db_test_enc)
-
-set_tests_properties(oelldb-test PROPERTIES PASS_REGULAR_EXPRESSION
-                                            "oelldb test passed")
-
-add_test(
-  NAME oelldb-test-simulation-mode
-  COMMAND
-    ${OE_BINDIR}/oelldb -o
-    "command script import ${CMAKE_CURRENT_SOURCE_DIR}/commands.py" -o "quit"
-    -- host/db_test_host enc/db_test_enc --simulation-mode)
-
-set_tests_properties(oelldb-test-simulation-mode
-                     PROPERTIES PASS_REGULAR_EXPRESSION "oelldb test passed")
diff --git a/tests/edl_opt_out/enc/CMakeLists.txt b/tests/edl_opt_out/enc/CMakeLists.txt
index 802b24407..52415da75 100644
--- a/tests/edl_opt_out/enc/CMakeLists.txt
+++ b/tests/edl_opt_out/enc/CMakeLists.txt
@@ -26,7 +26,6 @@ add_enclave(
   UUID
   892e7f65-5da1-45d0-8209-53795ce5be8f
   CRYPTO_LIB
-  OpenSSL
   SOURCES
   enc.c
   ${CMAKE_CURRENT_BINARY_DIR}/edl_opt_out_t.c)
diff --git a/tests/edl_opt_out/enc/enc.c b/tests/edl_opt_out/enc/enc.c
index 840d10c4e..648a7922b 100644
--- a/tests/edl_opt_out/enc/enc.c
+++ b/tests/edl_opt_out/enc/enc.c
@@ -171,9 +171,6 @@ void enc_edl_opt_out()
 
     /* sgx/entropy.edl */
     /* Only available with oecryptoopenssl */
-    OE_TEST(
-        oe_sgx_get_additional_host_entropy_ocall(NULL, NULL, 0) ==
-        OE_UNSUPPORTED);
 #endif
 }
 
diff --git a/tests/invalid_image/main.cpp b/tests/invalid_image/main.cpp
index c32f0d0f8..88cfb8708 100644
--- a/tests/invalid_image/main.cpp
+++ b/tests/invalid_image/main.cpp
@@ -10,5 +10,6 @@ int main(int, char* argv[])
     // expect failure
     // Linux  : ELF type is EXEC and not DYN
     // Windows: image is not ELF
-    OE_TEST(oe_load_elf_enclave_image(argv[0], &image) == OE_INVALID_IMAGE);
+    OE_TEST(
+        oe_load_elf_enclave_image(argv[0], &image, NULL) == OE_INVALID_IMAGE);
 }
diff --git a/tests/mbed/enc/enc.c b/tests/mbed/enc/enc.c
index 2c82b6c72..2ddd2619a 100644
--- a/tests/mbed/enc/enc.c
+++ b/tests/mbed/enc/enc.c
@@ -130,6 +130,7 @@ OE_DEFINE_SYSCALL3_M(SYS_writev)
     // expecting the runtime implementation of SYS_writev to also be
     // called.
     tls_result = OE_UNSUPPORTED;
+    errno = 1; // EDG: we don't accept a return value of -1 with errno=0
     return ret;
 }
 
diff --git a/tests/mman/enc/enc.c b/tests/mman/enc/enc.c
index ae0d41a1e..3fe14efdc 100644
--- a/tests/mman/enc/enc.c
+++ b/tests/mman/enc/enc.c
@@ -30,7 +30,6 @@ static void _test_basic()
 
     OE_TEST(munmap(ptr, chunk_size) == 0);
     OE_TEST(errno == 0);
-    OE_TEST(oe_test_get_mappings() == NULL);
 }
 
 static void _test_partial_unmapping(void)
@@ -45,10 +44,6 @@ static void _test_partial_unmapping(void)
         0);
     uint64_t p1_end = p1_start + p1_length;
 
-    oe_mapping_t* m = oe_test_get_mappings();
-    OE_TEST(m->start == p1_start);
-    OE_TEST(m->end == p1_end);
-
     uint64_t p2_length = 3 * OE_PAGE_SIZE;
     uint64_t p2_start = (uint64_t)mmap(
         NULL,
@@ -58,9 +53,6 @@ static void _test_partial_unmapping(void)
         -1,
         0);
     uint64_t p2_end = p2_start + p2_length;
-    m = oe_test_get_mappings();
-    OE_TEST(m->start == p2_start);
-    OE_TEST(m->end == p2_end);
 
     // Swap p1 and p2 if p2 lies before p1.
     if (p2_start < p1_start)
@@ -81,30 +73,15 @@ static void _test_partial_unmapping(void)
     OE_TEST(errno == 0);
 
     // Partial unmapping only changes the status vectors and not the bounds.
-    m = oe_test_get_mappings();
-    OE_TEST(m->start == p2_start);
-    OE_TEST(m->end == p2_end);
-    m = m->next;
-    OE_TEST(m->start == p1_start);
-    OE_TEST(m->end == p1_end);
 
     // Do another partial unmap.
     start -= OE_PAGE_SIZE;
     OE_TEST(munmap((void*)start, end - start) == 0);
     OE_TEST(errno == 0);
-    m = oe_test_get_mappings();
-    OE_TEST(m->start == p2_start);
-    OE_TEST(m->end == p2_end);
-    m = m->next;
-    OE_TEST(m->start == p1_start);
-    OE_TEST(m->end == p1_end);
 
     // Do an unmap till the start.
     // This ought to delete one mapping completely.
-    OE_TEST(munmap((void*)OE_PAGE_SIZE, start - OE_PAGE_SIZE) == 0);
     OE_TEST(errno == 0);
-    m = oe_test_get_mappings();
-    OE_TEST(m->next == NULL);
 
     // Do another unmapping that spans entire enclave memory.
     // This ought to get rid of all mappings.
@@ -115,21 +92,15 @@ static void _test_partial_unmapping(void)
             MAP_FAILED);
         OE_TEST(errno == 0);
     }
-    OE_TEST(munmap(0, (1L << 62)) == 0);
     OE_TEST(errno == 0);
-    OE_TEST(oe_test_get_mappings() == NULL);
 
     // Test unmapping a mapping in small chunks.
     start = (uint64_t)mmap(
         NULL, 3 * OE_PAGE_SIZE, PROT_READ, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
-    OE_TEST(oe_test_get_mappings() != NULL);
 
     OE_TEST(munmap((void*)(start + OE_PAGE_SIZE), 1) == 0);
-    OE_TEST(oe_test_get_mappings() != NULL);
     OE_TEST(munmap((void*)(start + 2 * OE_PAGE_SIZE), 1) == 0);
-    OE_TEST(oe_test_get_mappings() != NULL);
     OE_TEST(munmap((void*)start, 1) == 0);
-    OE_TEST(oe_test_get_mappings() == NULL);
 }
 
 static void _test_mmap_params(void)
@@ -142,8 +113,8 @@ static void _test_mmap_params(void)
             PROT_READ,
             MAP_ANONYMOUS | MAP_PRIVATE,
             -1,
-            0) != MAP_FAILED);
-    OE_TEST(errno == 0);
+            0) == MAP_FAILED);
+    OE_TEST(errno == EINVAL);
 
     // Zero length should fail.
     OE_TEST(
@@ -164,15 +135,16 @@ static void _test_mmap_params(void)
     OE_TEST(errno == ENOMEM);
 
     // Test various prots.
+    errno = 0;
     OE_TEST(
-        mmap(NULL, chunk_size, 0, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0) ==
+        mmap(NULL, chunk_size, 0, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0) !=
         MAP_FAILED);
-    OE_TEST(errno == EINVAL);
+    OE_TEST(errno == 0);
 
     OE_TEST(
-        mmap(NULL, chunk_size, PROT_EXEC, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0) ==
+        mmap(NULL, chunk_size, PROT_EXEC, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0) !=
         MAP_FAILED);
-    OE_TEST(errno == EINVAL);
+    OE_TEST(errno == 0);
 
     errno = 0;
     OE_TEST(
@@ -203,8 +175,8 @@ static void _test_mmap_params(void)
 
     // Test various flags.
     OE_TEST(
-        mmap(NULL, chunk_size, PROT_READ | PROT_WRITE, 0, -1, 0) == MAP_FAILED);
-    OE_TEST(errno == EINVAL);
+        mmap(NULL, chunk_size, PROT_READ | PROT_WRITE, 0, -1, 0) != MAP_FAILED);
+    OE_TEST(errno == 0);
 
     errno = 0;
     // One of MAP_SHARED, MAP_SHARED_VALIDATE, MAP_PRIVATE must be used.
@@ -229,9 +201,9 @@ static void _test_mmap_params(void)
     OE_TEST(errno == 0);
 
     OE_TEST(
-        mmap(NULL, chunk_size, PROT_READ | PROT_WRITE, MAP_ANONYMOUS, -1, 0) ==
+        mmap(NULL, chunk_size, PROT_READ | PROT_WRITE, MAP_ANONYMOUS, -1, 0) !=
         MAP_FAILED);
-    OE_TEST(errno == EINVAL);
+    OE_TEST(errno == 0);
 
     errno = 0;
     // Test unsupported flags.
@@ -244,7 +216,6 @@ static void _test_mmap_params(void)
 #ifdef MAP_32BIT
         MAP_32BIT,
 #endif
-        MAP_FIXED,
         MAP_FIXED_NOREPLACE,
         MAP_GROWSDOWN,
         MAP_HUGETLB,
@@ -262,7 +233,7 @@ static void _test_mmap_params(void)
                 unsupported[i] | MAP_PRIVATE,
                 0,
                 0) == MAP_FAILED);
-        OE_TEST(errno == EINVAL);
+        OE_TEST(errno == ENOSYS);
     }
 
     int ignored[] = {
@@ -278,7 +249,8 @@ static void _test_mmap_params(void)
     {
         errno = 0;
         OE_TEST(
-            mmap(NULL, chunk_size, PROT_READ, ignored[i] | MAP_PRIVATE, 0, 0) !=
+            mmap(
+                NULL, chunk_size, PROT_READ, ignored[i] | MAP_PRIVATE, -1, 0) !=
             MAP_FAILED);
         OE_TEST(errno == 0);
     }
@@ -329,8 +301,8 @@ static void _test_unmap_params(void)
         for (size_t j = 0; j < OE_COUNTOF(lengths); ++j)
         {
             errno = -1;
-            OE_TEST(munmap(ptrs[i], lengths[j]) == 0);
-            OE_TEST(errno == 0);
+            OE_TEST(munmap(ptrs[i], lengths[j]) == -1);
+            OE_TEST(errno == EINVAL);
         }
     }
 
diff --git a/tests/module_loading/CMakeLists.txt b/tests/module_loading/CMakeLists.txt
index 66b27aa56..f9df67921 100644
--- a/tests/module_loading/CMakeLists.txt
+++ b/tests/module_loading/CMakeLists.txt
@@ -55,16 +55,5 @@ if (BUILD_TYPE_UPPER STREQUAL "DEBUG" OR BUILD_TYPE_UPPER STREQUAL
         --command=${CMAKE_CURRENT_SOURCE_DIR}/commands.gdb
         --return-child-result # This fails the test in case of any error.
         -arg host/module_loading_host enc/module_loading_enc)
-
-    add_test(
-      NAME oelldb-multi-module-test
-      COMMAND
-        ${OE_BINDIR}/oelldb -o
-        "command script import ${CMAKE_CURRENT_SOURCE_DIR}/commands.py" -o
-        "quit" -- host/module_loading_host enc/module_loading_enc)
-
-    set_tests_properties(
-      oelldb-multi-module-test PROPERTIES PASS_REGULAR_EXPRESSION
-                                          "oelldb-multi-module-test passed")
   endif ()
 endif ()
diff --git a/tests/module_loading/enc/CMakeLists.txt b/tests/module_loading/enc/CMakeLists.txt
index 90d0d7e2e..d17c9028c 100644
--- a/tests/module_loading/enc/CMakeLists.txt
+++ b/tests/module_loading/enc/CMakeLists.txt
@@ -14,8 +14,7 @@ add_enclave_library(module_loading_common OBJECT enc.c
                     ${CMAKE_CURRENT_BINARY_DIR}/module_loading_t.c)
 enclave_include_directories(module_loading_common PRIVATE
                             ${CMAKE_CURRENT_BINARY_DIR})
-enclave_link_libraries(module_loading_common oeenclave oecryptoopenssl oelibc
-                       oe_includes)
+enclave_link_libraries(module_loading_common oeenclave oelibc oe_includes)
 maybe_build_using_clangw(module_loading_common)
 
 # Add the enclave for postive tests
diff --git a/tests/module_loading/module/module.c b/tests/module_loading/module/module.c
index 1e9315794..099ace1e7 100644
--- a/tests/module_loading/module/module.c
+++ b/tests/module_loading/module/module.c
@@ -57,7 +57,6 @@ int test_libc_symbols()
     TEST_SYMBOL(memcpy);
     TEST_SYMBOL(memmove);
     TEST_SYMBOL(memset);
-    TEST_SYMBOL(oe_sgx_get_additional_host_entropy);
     TEST_SYMBOL(pthread_mutex_destroy);
     TEST_SYMBOL(pthread_mutex_init);
     TEST_SYMBOL(pthread_mutex_lock);
@@ -71,9 +70,5 @@ int test_libc_symbols()
     if (sizeof(pthread_mutex_t) != 40)
         return 0;
 
-    uint8_t data[16];
-    if (!oe_sgx_get_additional_host_entropy(data, 16))
-        return 0;
-
     return 1;
 }
diff --git a/tests/pf_gp_exceptions/host/host.c b/tests/pf_gp_exceptions/host/host.c
index 8e3997d8d..f94f8c93c 100644
--- a/tests/pf_gp_exceptions/host/host.c
+++ b/tests/pf_gp_exceptions/host/host.c
@@ -42,7 +42,10 @@ int main(int argc, const char* argv[])
     if (result != OE_OK)
         oe_put_err("oe_create_enclave(): result=%u", result);
 
-    if (_is_misc_region_supported())
+    if (flags & OE_ENCLAVE_FLAG_SIMULATE)
+        printf("Simulation mode does not support exceptions. Skip the test "
+               "ECALL.\n");
+    else if (_is_misc_region_supported())
     {
         result = enc_pf_gp_exceptions(enclave, &return_value);
         if (result != OE_OK)
diff --git a/tests/props/host/host.c b/tests/props/host/host.c
index 6d95d6943..abfb269b9 100644
--- a/tests/props/host/host.c
+++ b/tests/props/host/host.c
@@ -62,7 +62,7 @@ static oe_result_t _sgx_load_enclave_properties(
         OE_RAISE(OE_INVALID_PARAMETER);
 
     /* Load the ELF image */
-    if (oe_load_enclave_image(path, &oeimage) != 0)
+    if (oe_load_enclave_image(path, &oeimage, NULL) != 0)
         OE_RAISE(OE_FAILURE);
 
     /* Load the SGX enclave properties */
diff --git a/tests/sealKey/host/host.cpp b/tests/sealKey/host/host.cpp
index 10286da24..db9188cf7 100644
--- a/tests/sealKey/host/host.cpp
+++ b/tests/sealKey/host/host.cpp
@@ -156,11 +156,6 @@ int main(int argc, const char* argv[])
     }
 
     const uint32_t flags = oe_get_create_flags();
-    if ((flags & OE_ENCLAVE_FLAG_SIMULATE) != 0)
-    {
-        printf("=== Skipped unsupported test in simulation mode (sealKey)\n");
-        return SKIP_RETURN_CODE;
-    }
 
     printf("=== This program is used to test enclave seal key functions.\n");
 
diff --git a/tests/sgx_zerobase/CMakeLists.txt b/tests/sgx_zerobase/CMakeLists.txt
index e1d5dc8ea..879c96308 100644
--- a/tests/sgx_zerobase/CMakeLists.txt
+++ b/tests/sgx_zerobase/CMakeLists.txt
@@ -9,19 +9,27 @@ endif ()
 
 add_enclave_test(tests/sgx_zerobase_macro_only sgx_zerobase_host
                  sgx_zerobase_macro_only_enc)
+set_enclave_tests_properties(tests/sgx_zerobase_macro_only PROPERTIES
+                             SKIP_RETURN_CODE 2)
 
 # Tests 0-base enclave creation when OE_SET_ENCLAVE_SGX*() macro is not
 # used and only oesign configuration file is used to set properties.
 add_enclave_test(tests/sgx_zerobase_conf_only sgx_zerobase_host
                  sgx_zerobase_conf_only_enc_signed)
+set_enclave_tests_properties(tests/sgx_zerobase_conf_only PROPERTIES
+                             SKIP_RETURN_CODE 2)
 
 # Tests 0-base enclave creation when OE_SET_ENCLAVE_SGX*() macro disables
 # 0-base enclave creation and oesign configuration file enables 0-base enclave creation.
 add_enclave_test(
   tests/sgx_zerobase_prop_macro_disable_conf_enable sgx_zerobase_host
   sgx_zerobase_macro_disable_conf_enable_enc_signed)
+set_enclave_tests_properties(tests/sgx_zerobase_prop_macro_disable_conf_enable
+                             PROPERTIES SKIP_RETURN_CODE 2)
 
 # Tests 0-base enclave creation when OE_SET_ENCLAVE_SGX*() macro enables
 # 0-base enclave creation but oesign configuration file disables 0-base enclave creation.
 add_enclave_test(tests/sgx_zerobase_macro_enable_conf_disable sgx_zerobase_host
                  sgx_zerobase_macro_enable_conf_disable_enc_signed)
+set_enclave_tests_properties(tests/sgx_zerobase_macro_enable_conf_disable
+                             PROPERTIES SKIP_RETURN_CODE 2)
diff --git a/tests/sgx_zerobase/host/host.cpp b/tests/sgx_zerobase/host/host.cpp
index 104902bfb..a04f775aa 100644
--- a/tests/sgx_zerobase/host/host.cpp
+++ b/tests/sgx_zerobase/host/host.cpp
@@ -4,6 +4,8 @@
 #include <openenclave/bits/exception.h>
 #include <openenclave/host.h>
 #include <openenclave/internal/error.h>
+#include <openenclave/internal/raise.h>
+#include <openenclave/internal/sgx/tests.h>
 #include <openenclave/internal/tests.h>
 #include <sys/mman.h>
 #include <iostream>
@@ -11,6 +13,8 @@
 #include "../host/sgx/cpuid.h"
 #include "sgx_zerobase_u.h"
 
+#define SKIP_RETURN_CODE 2
+
 const char* message = "Hello world from Host\n\0";
 
 static bool _is_misc_region_supported()
@@ -46,6 +50,13 @@ int main(int argc, const char* argv[])
         return 1;
     }
 
+    if (!oe_has_sgx_quote_provider())
+    {
+        // this test should not run on any platforms where FLC is not supported
+        OE_TRACE_INFO("=== tests skipped when DCAP libraries are not found.\n");
+        return SKIP_RETURN_CODE;
+    }
+
     if (strstr(argv[1], "_conf_") == NULL)
     {
         fprintf(
diff --git a/tests/syscall/fs/enc/enc.cpp b/tests/syscall/fs/enc/enc.cpp
index db536819d..75f456101 100644
--- a/tests/syscall/fs/enc/enc.cpp
+++ b/tests/syscall/fs/enc/enc.cpp
@@ -450,6 +450,42 @@ static void test_unlink_file(FILE_SYSTEM& fs, const char* tmp_dir)
     OE_TEST(fs.stat(path, &buf) != 0);
 }
 
+template <class FILE_SYSTEM>
+static void test_flock_file(FILE_SYSTEM& fs, const char* tmp_dir)
+{
+    char path[OE_PAGE_SIZE];
+
+    printf("--- %s()\n", __FUNCTION__);
+
+    mkpath(path, tmp_dir, "alphabet");
+
+    /* Lock the file. */
+    const auto file = fs.open(path, O_RDONLY, 0);
+    OE_TEST(file);
+    OE_TEST(fs.flock(file, LOCK_EX) == 0);
+
+    /* Try to lock the file using another handle. */
+    const auto file2 = fs.open(path, O_RDONLY, 0);
+    OE_TEST(file2);
+#ifndef ERT_TEST_MEMFS
+    OE_TEST(fs.flock(file2, LOCK_EX | LOCK_NB) == -1);
+    OE_TEST(errno == EWOULDBLOCK);
+#endif
+
+    /* Closing should unlock the file. */
+    OE_TEST(fs.close(file) == 0);
+    OE_TEST(fs.flock(file2, LOCK_EX) == 0);
+    OE_TEST(fs.close(file2) == 0);
+
+    // EDG: lock folder
+    const auto folder = fs.open(tmp_dir, O_RDONLY, 0);
+    OE_TEST(folder);
+#ifndef ERT_TEST_MMAPFS
+    OE_TEST(fs.flock(folder, LOCK_EX) == 0);
+#endif
+    OE_TEST(fs.close(folder) == 0);
+}
+
 template <class FILE_SYSTEM>
 static void test_invalid_path(FILE_SYSTEM& fs)
 {
@@ -485,6 +521,7 @@ void test_pio(FILE_SYSTEM& fs, const char* tmp_dir)
     test_create_file(fs, tmp_dir);
     test_pread_file(fs, tmp_dir);
     test_pwrite_file(fs, tmp_dir);
+    test_flock_file(fs, tmp_dir);
     cleanup(fs, tmp_dir);
 }
 
diff --git a/tests/syscall/fs/enc/file_system.h b/tests/syscall/fs/enc/file_system.h
index ec2e40a6d..fa510c038 100644
--- a/tests/syscall/fs/enc/file_system.h
+++ b/tests/syscall/fs/enc/file_system.h
@@ -18,6 +18,7 @@
 #include <openenclave/internal/syscall/sys/stat.h>
 #include <openenclave/internal/syscall/unistd.h>
 #include <stdio.h>
+#include <sys/file.h>
 #include <sys/stat.h>
 #include <sys/types.h>
 #include <unistd.h>
@@ -81,6 +82,11 @@ class oe_fd_file_system
         return oe_fdatasync(file);
     }
 
+    int flock(file_handle file, int operation)
+    {
+        return oe_flock(file, operation);
+    }
+
     int close(file_handle file)
     {
         return oe_close(file);
@@ -251,6 +257,11 @@ class fd_file_system
         return ::fdatasync(file);
     }
 
+    int flock(file_handle file, int operation)
+    {
+        return ::flock(file, operation);
+    }
+
     int close(file_handle file)
     {
         return ::close(file);
@@ -539,6 +550,11 @@ class stream_file_system
         return fflush(file);
     }
 
+    int flock(file_handle file, int operation)
+    {
+        return ::flock(fileno(file), operation);
+    }
+
     int close(file_handle file)
     {
         return ::fclose(file);
diff --git a/tests/syscall/getrandom/enc/enc.c b/tests/syscall/getrandom/enc/enc.c
index 98e48740e..a75ab0ba0 100644
--- a/tests/syscall/getrandom/enc/enc.c
+++ b/tests/syscall/getrandom/enc/enc.c
@@ -24,10 +24,6 @@ void test_getrandom()
     OE_TEST((size_t)size == sizeof(buflen));
 
     /* Test with unsupported flags */
-    OE_TEST(getrandom((void*)buf, sizeof(buflen), GRND_RANDOM) == -1);
-    OE_TEST(errno == EINVAL);
-    OE_TEST(getrandom((void*)buf, sizeof(buflen), GRND_NONBLOCK) == -1);
-    OE_TEST(errno == EINVAL);
 }
 
 OE_SET_ENCLAVE_SGX(
diff --git a/tests/syscall/poller/client.cpp b/tests/syscall/poller/client.cpp
index c09560c7f..927be2ded 100644
--- a/tests/syscall/poller/client.cpp
+++ b/tests/syscall/poller/client.cpp
@@ -17,7 +17,7 @@
 
 extern "C" void oe_abort();
 
-void run_client(uint16_t port)
+void run_client(uint32_t ipaddr, uint16_t port)
 {
     socket_t sd;
     const char alphabet[] = "abcdefghijklmnopqrstuvwxyz";
@@ -37,7 +37,7 @@ void run_client(uint16_t port)
         struct sockaddr_in addr;
         memset(&addr, 0, sizeof(addr));
         addr.sin_family = AF_INET;
-        addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
+        addr.sin_addr.s_addr = htonl(ipaddr);
         addr.sin_port = htons(port);
 
         if (connect(sd, (struct sockaddr*)&addr, sizeof(addr)) != 0)
diff --git a/tests/syscall/poller/client.h b/tests/syscall/poller/client.h
index 060657741..a57d92704 100644
--- a/tests/syscall/poller/client.h
+++ b/tests/syscall/poller/client.h
@@ -6,6 +6,6 @@
 
 #include <stdint.h>
 
-void run_client(uint16_t port);
+void run_client(uint32_t ipaddr, uint16_t port);
 
 #endif /* _OE_TESTS_LIBCSOCKETS_CLIENT_H */
diff --git a/tests/syscall/poller/enc/enc.cpp b/tests/syscall/poller/enc/enc.cpp
index a8ee8b96f..b8bcd22c6 100644
--- a/tests/syscall/poller/enc/enc.cpp
+++ b/tests/syscall/poller/enc/enc.cpp
@@ -22,18 +22,19 @@ static void _init(void)
 }
 
 extern "C" void run_enclave_server(
+    uint32_t ipaddr,
     uint16_t port,
     size_t num_clients,
     uint32_t poller_type)
 {
     _init();
-    run_server(port, num_clients, poller_type_t(poller_type));
+    run_server(ipaddr, port, num_clients, poller_type_t(poller_type));
 }
 
-extern "C" void run_enclave_client(uint16_t port)
+extern "C" void run_enclave_client(uint32_t ipaddr, uint16_t port)
 {
     _init();
-    run_client(port);
+    run_client(ipaddr, port);
 }
 
 extern "C" void test_fd_set(void)
diff --git a/tests/syscall/poller/host/host.cpp b/tests/syscall/poller/host/host.cpp
index 1c4cd0833..a107308ca 100644
--- a/tests/syscall/poller/host/host.cpp
+++ b/tests/syscall/poller/host/host.cpp
@@ -22,12 +22,13 @@ static oe_enclave_t* _enclave;
 typedef struct thread_arg
 {
     poller_type_t poller_type;
+    uint32_t ipaddr;
 } server_arg_t;
 
 static void* _run_host_client(void* arg)
 {
     OE_UNUSED(arg);
-    run_client(PORT);
+    run_client(static_cast<thread_arg*>(arg)->ipaddr, PORT);
     return NULL;
 }
 
@@ -35,7 +36,7 @@ static void* _run_host_server(void* arg_)
 {
     server_arg_t* arg = (server_arg_t*)arg_;
 
-    run_server(PORT, NUM_CLIENTS, arg->poller_type);
+    run_server(arg->ipaddr, PORT, NUM_CLIENTS, arg->poller_type);
 
     return NULL;
 }
@@ -44,7 +45,8 @@ static void* _run_enclave_server(void* arg_)
 {
     server_arg_t* arg = (server_arg_t*)arg_;
 
-    run_enclave_server(_enclave, PORT, NUM_CLIENTS, arg->poller_type);
+    run_enclave_server(
+        _enclave, arg->ipaddr, PORT, NUM_CLIENTS, arg->poller_type);
 
     return NULL;
 }
@@ -53,7 +55,7 @@ static void* _run_enclave_client(void* arg)
 {
     OE_UNUSED(arg);
 
-    run_enclave_client(_enclave, PORT);
+    run_enclave_client(_enclave, static_cast<thread_arg*>(arg)->ipaddr, PORT);
 
     return NULL;
 }
@@ -61,11 +63,12 @@ static void* _run_enclave_client(void* arg)
 void run_test(
     void* (*client_proc)(void*),
     void* (*server_proc)(void*),
-    poller_type_t poller_type)
+    poller_type_t poller_type,
+    uint32_t ipaddr = INADDR_LOOPBACK)
 {
     thread_t clients[NUM_CLIENTS];
     thread_t server;
-    server_arg_t arg = {poller_type};
+    thread_arg arg = {poller_type, ipaddr};
 
     if (thread_create(&server, server_proc, &arg) != 0)
     {
@@ -76,7 +79,7 @@ void run_test(
 
     for (size_t i = 0; i < NUM_CLIENTS; i++)
     {
-        if (thread_create(&clients[i], client_proc, NULL) != 0)
+        if (thread_create(&clients[i], client_proc, &arg) != 0)
         {
             OE_TEST("thread_create()" == NULL);
         }
@@ -120,6 +123,14 @@ void test_enclave_to_enclave(poller_type_t poller_type)
     fflush(stdout);
 }
 
+static void test_enclave_to_enclave_internal(poller_type_t poller_type)
+{
+    printf("=== start %s(): %s\n", __FUNCTION__, poller::name(poller_type));
+    run_test(_run_enclave_client, _run_enclave_server, poller_type, 0xFF000001);
+    printf("=== passed %s(): %s\n", __FUNCTION__, poller::name(poller_type));
+    fflush(stdout);
+}
+
 int main(int argc, const char* argv[])
 {
     oe_result_t r;
@@ -154,6 +165,7 @@ int main(int argc, const char* argv[])
     test_enclave_to_host(poller_type);
     test_host_to_enclave(poller_type);
     test_enclave_to_enclave(poller_type);
+    test_enclave_to_enclave_internal(poller_type);
 
     test_fd_set(_enclave);
 
diff --git a/tests/syscall/poller/poller.edl b/tests/syscall/poller/poller.edl
index 419c4d27a..52858f4b5 100644
--- a/tests/syscall/poller/poller.edl
+++ b/tests/syscall/poller/poller.edl
@@ -12,15 +12,18 @@ enclave {
 #else
     from "openenclave/edl/optee/platform.edl" import *;
 #endif
+    from "openenclave/edl/syscall.edl" import oe_syscall_eventfd_ocall;
 
     trusted {
 
         public void run_enclave_server(
+            uint32_t ipaddr,
             uint16_t port,
             size_t num_clients,
             uint32_t poller_type);
 
         public void run_enclave_client(
+            uint32_t ipaddr,
             uint16_t port);
 
         public void test_fd_set();
diff --git a/tests/syscall/poller/server.cpp b/tests/syscall/poller/server.cpp
index 8e656ab3e..e1305920c 100644
--- a/tests/syscall/poller/server.cpp
+++ b/tests/syscall/poller/server.cpp
@@ -19,7 +19,7 @@
 
 extern "C" void oe_abort();
 
-socket_t create_listener_socket(uint16_t port)
+socket_t create_listener_socket(uint32_t ipaddr, uint16_t port)
 {
     socket_t ret = INVALID_SOCKET;
     socket_t sock = INVALID_SOCKET;
@@ -36,7 +36,7 @@ socket_t create_listener_socket(uint16_t port)
 
     memset(&addr, 0, sizeof(addr));
     addr.sin_family = AF_INET;
-    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
+    addr.sin_addr.s_addr = htonl(ipaddr);
     addr.sin_port = htons(port);
 
     if (bind(sock, (struct sockaddr*)&addr, sizeof(addr)) != 0)
@@ -75,6 +75,7 @@ client_t* find_client(std::vector<client_t>& clients, socket_t sock)
 }
 
 extern "C" void run_server(
+    uint32_t ipaddr,
     uint16_t port,
     size_t num_clients,
     poller_type_t poller_type)
@@ -89,7 +90,7 @@ extern "C" void run_server(
 
     sock_startup();
 
-    if ((listener = create_listener_socket(port)) == INVALID_SOCKET)
+    if ((listener = create_listener_socket(ipaddr, port)) == INVALID_SOCKET)
     {
         OE_TEST("create_listener_socket() failed" == NULL);
     }
diff --git a/tests/syscall/poller/server.h b/tests/syscall/poller/server.h
index 786180db6..d8582b1de 100644
--- a/tests/syscall/poller/server.h
+++ b/tests/syscall/poller/server.h
@@ -8,6 +8,7 @@
 #include "poller.h"
 
 extern "C" void run_server(
+    uint32_t ipaddr,
     uint16_t port,
     size_t num_clients,
     poller_type_t poller_type);
diff --git a/tests/syscall/resolver/enc/enc.c b/tests/syscall/resolver/enc/enc.c
index 032861859..62ffb759c 100644
--- a/tests/syscall/resolver/enc/enc.c
+++ b/tests/syscall/resolver/enc/enc.c
@@ -18,9 +18,12 @@ size_t oe_debug_malloc_check();
 
 struct addrinfo;
 
+static bool _initialized;
+
 int ecall_device_init()
 {
     OE_TEST(oe_load_module_host_resolver() == OE_OK);
+    _initialized = true;
     return 0;
 }
 
@@ -51,11 +54,35 @@ int ecall_getnameinfo(char* buffer, size_t bufflen)
         0);
 
     OE_TEST(rslt == 0);
-    OE_TEST(strcmp(host, "") != 0);
-    OE_TEST(strcmp(serv, "") != 0);
+    OE_TEST(strcmp(host, "127.0.0.1") == 0);
+    OE_TEST(strcmp(serv, "23") == 0);
 
     strlcpy(buffer, host, bufflen);
 
+    *host = 0;
+    *serv = 0;
+
+    // test with NI_NAMEREQD
+    rslt = oe_getnameinfo(
+        (const struct oe_sockaddr*)&addr,
+        sizeof(addr),
+        host,
+        sizeof(host),
+        serv,
+        sizeof(serv),
+        OE_NI_NAMEREQD);
+
+    if (_initialized)
+    {
+        // expect that it can be resolved by the host
+        OE_TEST(rslt == 0);
+        OE_TEST(*host);
+        OE_TEST(*serv);
+    }
+    else
+        // with NI_NAMEREQD it cannot be resolved internally
+        OE_TEST(rslt == OE_EAI_SYSTEM);
+
     return 0;
 }
 
@@ -173,7 +200,8 @@ done:
 int ecall_getaddrinfo(struct oe_addrinfo** res)
 {
     struct oe_addrinfo* ai = NULL;
-    const char host[] = {"localhost"};
+    const char host[] = {
+        "lOcalhOst"}; // capital letters force external resolution
     const char serv[] = {"telnet"};
     struct oe_addrinfo hints;
 
@@ -194,6 +222,36 @@ int ecall_getaddrinfo(struct oe_addrinfo** res)
     return 0;
 }
 
+void ecall_getaddrinfo_internally(void)
+{
+    struct oe_addrinfo* ai = NULL;
+
+    OE_TEST(oe_getaddrinfo("2.3.4.5", "1111", NULL, &ai) == 0);
+    OE_TEST(ai && ai->ai_addr);
+    OE_TEST(ai->ai_addr->sa_family == AF_INET);
+    const struct oe_sockaddr_in* ad = (struct oe_sockaddr_in*)ai->ai_addr;
+    OE_TEST(ntohl(ad->sin_addr.s_addr) == 0x02030405);
+    OE_TEST(ntohs(ad->sin_port) == 1111);
+    oe_freeaddrinfo(ai);
+
+    // IP addresses should never be resolved by the host.
+    // Named services cannot be resolved internally so the following fails.
+    // (We may implement internal service name resolution if we ever need it.)
+    ai = NULL;
+    OE_TEST(oe_getaddrinfo("2.3.4.5", "telnet", NULL, &ai) == OE_EAI_SERVICE);
+    OE_TEST(!ai);
+
+    // localhost can be resolved internally
+    ai = NULL;
+    OE_TEST(oe_getaddrinfo("localhost", "1111", NULL, &ai) == 0);
+    OE_TEST(ai && ai->ai_addr);
+    OE_TEST(ai->ai_addr->sa_family == AF_INET);
+    ad = (struct oe_sockaddr_in*)ai->ai_addr;
+    OE_TEST(ntohl(ad->sin_addr.s_addr) == OE_INADDR_LOOPBACK);
+    OE_TEST(ntohs(ad->sin_port) == 1111);
+    oe_freeaddrinfo(ai);
+}
+
 OE_SET_ENCLAVE_SGX(
     1,    /* ProductID */
     1,    /* SecurityVersion */
diff --git a/tests/syscall/resolver/host/host.c b/tests/syscall/resolver/host/host.c
index e331b4372..5ab91f2a8 100644
--- a/tests/syscall/resolver/host/host.c
+++ b/tests/syscall/resolver/host/host.c
@@ -66,6 +66,11 @@ int main(int argc, const char* argv[])
 
     OE_TEST(result == OE_OK);
 
+    // test without host resolver loaded
+    OE_TEST(ecall_getaddrinfo_internally(client_enclave) == OE_OK);
+    OE_TEST(
+        ecall_getnameinfo(client_enclave, &ret, host, sizeof(host)) == OE_OK);
+
     OE_TEST(ecall_device_init(client_enclave, &ret) == OE_OK);
 
     OE_TEST(ecall_getaddrinfo(client_enclave, &ret, &addrinfo) == OE_OK);
@@ -124,6 +129,9 @@ int main(int argc, const char* argv[])
         printf("host received: host = %s\n", host);
     }
 
+    // test with host resolver loaded
+    OE_TEST(ecall_getaddrinfo_internally(client_enclave) == OE_OK);
+
     OE_TEST(oe_terminate_enclave(client_enclave) == OE_OK);
 
     printf("=== passed all tests (resolver_test)\n");
diff --git a/tests/syscall/resolver/resolver_test.edl b/tests/syscall/resolver/resolver_test.edl
index 71cc46369..5cd14e2b4 100644
--- a/tests/syscall/resolver/resolver_test.edl
+++ b/tests/syscall/resolver/resolver_test.edl
@@ -18,6 +18,8 @@ enclave {
         public int ecall_getaddrinfo(
             [in,out,count=1] struct oe_addrinfo** res);
 
+        public void ecall_getaddrinfo_internally();
+
         public int ecall_getnameinfo(
             [in, out, count=bufflen] char* buffer,
             size_t bufflen);
diff --git a/tests/syscall/socket/enc/enc.c b/tests/syscall/socket/enc/enc.c
index 73e81ccf0..6bc91a008 100644
--- a/tests/syscall/socket/enc/enc.c
+++ b/tests/syscall/socket/enc/enc.c
@@ -39,7 +39,7 @@ static void _initialize()
 /* This client connects to an echo server, sends a text message,
  * and outputs the text reply.
  */
-int ecall_run_client(char* recv_buff, ssize_t* recv_buff_len)
+int ecall_run_client(uint32_t ipaddr, char* recv_buff, ssize_t* recv_buff_len)
 {
     _initialize();
     int sockfd = 0;
@@ -55,7 +55,7 @@ int ecall_run_client(char* recv_buff, ssize_t* recv_buff_len)
         return OE_FAILURE;
     }
     serv_addr.sin_family = OE_AF_INET;
-    serv_addr.sin_addr.s_addr = oe_htonl(OE_INADDR_LOOPBACK);
+    serv_addr.sin_addr.s_addr = oe_htonl(ipaddr);
     serv_addr.sin_port = oe_htons(1492);
 
     printf("socket fd = %d\n", sockfd);
@@ -117,7 +117,7 @@ int ecall_run_client(char* recv_buff, ssize_t* recv_buff_len)
 /* This server acts as an echo server.  It accepts a connection,
  * receives messages, and echoes them back.
  */
-int ecall_run_server()
+int ecall_run_server(uint32_t ipaddr)
 {
     _initialize();
     int status = OE_FAILURE;
@@ -136,8 +136,8 @@ int ecall_run_server()
     }
 
     serv_addr.sin_family = OE_AF_INET;
-    serv_addr.sin_addr.s_addr = oe_htonl(OE_INADDR_LOOPBACK);
-    serv_addr.sin_port = oe_htons(1493);
+    serv_addr.sin_addr.s_addr = oe_htonl(ipaddr);
+    serv_addr.sin_port = oe_htons(1492);
 
     printf("enclave: binding\n");
     rtn = oe_bind(listenfd, (struct oe_sockaddr*)&serv_addr, sizeof(serv_addr));
@@ -172,7 +172,7 @@ int ecall_run_server()
         OE_TEST(peer_addr_len == sizeof(peer_addr));
         OE_TEST(peer_addr.sin_family == OE_AF_INET);
         OE_TEST(oe_ntohs(peer_addr.sin_port) >= 1024);
-        OE_TEST(oe_ntohl(peer_addr.sin_addr.s_addr) == OE_INADDR_LOOPBACK);
+        OE_TEST(oe_ntohl(peer_addr.sin_addr.s_addr) == ipaddr);
 
         if (connfd >= 0)
         {
@@ -225,4 +225,4 @@ OE_SET_ENCLAVE_SGX(
     true, /* Debug */
     256,  /* NumHeapPages */
     256,  /* NumStackPages */
-    1);   /* NumTCS */
+    2);   /* NumTCS */
diff --git a/tests/syscall/socket/host/host.c b/tests/syscall/socket/host/host.c
index 05180cb6c..4c4a52fb6 100644
--- a/tests/syscall/socket/host/host.c
+++ b/tests/syscall/socket/host/host.c
@@ -32,7 +32,7 @@ void* enclave_server_thread(void* arg)
     r = oe_create_socket_test_enclave(arg, type, flags, NULL, 0, &enclave);
     OE_TEST(r == OE_OK);
 
-    OE_TEST(ecall_run_server(enclave, &retval) == OE_OK);
+    OE_TEST(ecall_run_server(enclave, &retval, INADDR_LOOPBACK) == OE_OK);
 
     return NULL;
 }
@@ -181,7 +181,8 @@ static void _run_host_server_test(const char* path)
 
     test_data_len = 1024;
     OE_TEST(
-        ecall_run_client(enclave, &ret, test_data_rtn, &test_data_len) ==
+        ecall_run_client(
+            enclave, &ret, INADDR_LOOPBACK, test_data_rtn, &test_data_len) ==
         OE_OK);
 
     printf("host received: %.*s\n", (int)test_data_len, test_data_rtn);
@@ -197,7 +198,7 @@ static void _run_enclave_server_test(const char* path)
 {
     static char TESTDATA[] = "This is TEST DATA\n";
     thread_t thread;
-    const in_port_t PORT = 1493;
+    const in_port_t PORT = 1492;
 
     // enclave server to host client
     OE_TEST(thread_create(&thread, enclave_server_thread, (void*)path) == 0);
@@ -217,6 +218,49 @@ static void _run_enclave_server_test(const char* path)
     printf("=== passed %s\n", __FUNCTION__);
 }
 
+static const uint32_t _internal_ipaddr = 0xFF000001;
+
+static void* internal_server_thread(void* arg)
+{
+    int retval;
+    OE_TEST(ecall_run_server(arg, &retval, _internal_ipaddr) == OE_OK);
+    return NULL;
+}
+
+static void _run_internal_server_test(const char* path)
+{
+    oe_enclave_t* enclave = NULL;
+    OE_TEST(
+        oe_create_socket_test_enclave(
+            path,
+            OE_ENCLAVE_TYPE_SGX,
+            oe_get_create_flags(),
+            NULL,
+            0,
+            &enclave) == OE_OK);
+
+    thread_t thread;
+    OE_TEST(thread_create(&thread, internal_server_thread, enclave) == 0);
+
+    // Give the server time to launch
+    sleep_msec(250);
+
+    int ret = 0;
+    char test_data_rtn[1024] = {0};
+    ssize_t test_data_len = 1024;
+    OE_TEST(
+        ecall_run_client(
+            enclave, &ret, _internal_ipaddr, test_data_rtn, &test_data_len) ==
+        OE_OK);
+
+    OE_TEST(ret == OE_OK);
+    printf("host received: %.*s\n", (int)test_data_len, test_data_rtn);
+
+    thread_join(thread);
+    OE_TEST(oe_terminate_enclave(enclave) == OE_OK);
+    printf("=== passed %s\n", __FUNCTION__);
+}
+
 int main(int argc, const char* argv[])
 {
     if (argc != 2)
@@ -232,6 +276,7 @@ int main(int argc, const char* argv[])
 
     _run_host_server_test(argv[1]);
     _run_enclave_server_test(argv[1]);
+    _run_internal_server_test(argv[1]);
 
     sock_cleanup();
 
diff --git a/tests/syscall/socket/socket_test.edl b/tests/syscall/socket/socket_test.edl
index 7767757c0..ade8012ea 100644
--- a/tests/syscall/socket/socket_test.edl
+++ b/tests/syscall/socket/socket_test.edl
@@ -14,8 +14,8 @@ enclave {
 
     trusted {
         /* define ECALLs here. */
-        public int ecall_run_client([in, out, count=1024]char *buf, [in, out, count=1]ssize_t *buflen);
-        public int ecall_run_server();
+        public int ecall_run_client(uint32_t ipaddr, [in, out, count=1024]char *buf, [in, out, count=1]ssize_t *buflen);
+        public int ecall_run_server(uint32_t ipaddr);
     };
 
     untrusted {
diff --git a/tests/threadcxx/enc/enc.cpp b/tests/threadcxx/enc/enc.cpp
index f116c9051..6afc87535 100644
--- a/tests/threadcxx/enc/enc.cpp
+++ b/tests/threadcxx/enc/enc.cpp
@@ -1,7 +1,6 @@
 // Copyright (c) Open Enclave SDK contributors.
 // Licensed under the MIT License.
 
-#include <openenclave/edger8r/enclave.h>
 #include <openenclave/enclave.h>
 #include <openenclave/internal/tests.h>
 #include <stdio.h>
diff --git a/tests/tools/oesign/test-enclave/host/host.c b/tests/tools/oesign/test-enclave/host/host.c
index 7a2e970fb..45523a262 100644
--- a/tests/tools/oesign/test-enclave/host/host.c
+++ b/tests/tools/oesign/test-enclave/host/host.c
@@ -45,7 +45,7 @@ int main(int argc, const char* argv[])
     bool is_kss_supported = _is_kss_supported();
 
     /* Load the ELF image */
-    if ((result = oe_load_enclave_image(argv[1], &oeimage)) != OE_OK)
+    if ((result = oe_load_enclave_image(argv[1], &oeimage, NULL)) != OE_OK)
     {
         oe_put_err("oe_load_enclave_image(): result=%u", result);
     }
diff --git a/tools/CMakeLists.txt b/tools/CMakeLists.txt
index 3e7b850fe..87d912c06 100644
--- a/tools/CMakeLists.txt
+++ b/tools/CMakeLists.txt
@@ -29,7 +29,9 @@ endif ()
 
 ExternalProject_Add(
   oeedger8r-cpp
-  SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR}/oeedger8r-cpp
+  URL ${CMAKE_CURRENT_SOURCE_DIR}/oeedger8r-cpp
+  SOURCE_DIR ${CMAKE_CURRENT_BINARY_DIR}/oeedger8r-cpp-src
+  PATCH_COMMAND patch -p1 < ${ERTSRC}/oeedger8r-cpp.patch
   BINARY_DIR ${CMAKE_CURRENT_BINARY_DIR}/oeedger8r-cpp
   CMAKE_ARGS -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}
              -DCMAKE_C_COMPILER=${EDGER8R_C_COMPILER}
diff --git a/tools/oesign/main.c b/tools/oesign/main.c
index cfcfb50bc..d9ad29551 100644
--- a/tools/oesign/main.c
+++ b/tools/oesign/main.c
@@ -26,20 +26,25 @@ int oesign(
     const char* x509,
     const char* engine_id,
     const char* engine_load_path,
-    const char* key_id);
+    const char* key_id,
+    const char* payload_path);
 int oedigest(
     const char* enclave,
     const char* conffile,
     const char* digest_file);
+int oesignerid(const char* keyfile);
+int eradump(const char* enc_bin);
 
 static const char _usage_gen[] =
     "Usage: %s <command> [options]\n"
     "\n"
     "Commands:\n"
-    "  sign  -  Sign the specified enclave.\n"
-    "  digest - Create a digest of the specified enclave for signing.\n"
-    "  dump  -  Print out the Open Enclave metadata for the specified "
+    "  sign      -  Sign the specified enclave.\n"
+    "  digest    -  Create a digest of the specified enclave for signing.\n"
+    "  dump      -  Print out the Open Enclave metadata for the specified "
     "enclave.\n"
+    "  signerid  -  Print out the signer ID for the specified public key.\n"
+    "  eradump   -  Generates enclave config in JSON format.\n"
     "\n"
     "For help with a specific command, enter \"%s <command> --help\"\n";
 
@@ -151,6 +156,24 @@ static const char _usage_dump[] =
     "signature information for the specified enclave.\n"
     "\n";
 
+static const char _usage_signerid[] =
+    "Usage: %s signerid -k KEY_FILE\n"
+    "\n"
+    "Options:\n"
+    "  -k, --key-file           path to the public key file of the signer in\n"
+    "                           PEM format.\n"
+    "\n"
+    "Description:\n"
+    "  This option prints the signer ID derived from a public key.\n"
+    "\n";
+
+static const char _usage_eradump[] =
+    "Usage: %s eradump -e ENCLAVE_IMAGE\n"
+    "\n"
+    "Options:\n"
+    "  -e, --enclave-image      path to enclave image file.\n"
+    "\n";
+
 int dump_parser(int argc, const char* argv[])
 {
     int ret = 0;
@@ -301,6 +324,7 @@ int sign_parser(int argc, const char* argv[])
     const char* engine_id = NULL;
     const char* engine_load_path = NULL;
     const char* key_id = NULL;
+    const char* payload_path = NULL;
 
     const struct option long_options[] = {
         {"help", no_argument, NULL, 'h'},
@@ -317,6 +341,7 @@ int sign_parser(int argc, const char* argv[])
         {"load-path", required_argument, NULL, 'p'},
         {"key-id", required_argument, NULL, 'i'},
 #endif
+        {"payload", required_argument, NULL, 0x101},
         {NULL, 0, NULL, 0},
     };
     const char short_options[] = "he:c:k:n:p:i:d:o:x:z:s:";
@@ -379,6 +404,9 @@ int sign_parser(int argc, const char* argv[])
                 key_id = optarg;
                 break;
 #endif
+            case 0x101:
+                payload_path = optarg;
+                break;
             case ':':
                 // Missing option argument
                 ret = 1;
@@ -456,7 +484,8 @@ int sign_parser(int argc, const char* argv[])
             x509,
             engine_id,
             engine_load_path,
-            key_id);
+            key_id,
+            payload_path);
     }
 
 done:
@@ -547,6 +576,122 @@ done:
     return ret;
 }
 
+static int _signerid_parser(int argc, const char* argv[])
+{
+    int ret = 0;
+    const char* keyfile = NULL;
+
+    const struct option long_options[] = {
+        {"help", no_argument, NULL, 'h'},
+        {"key-file", required_argument, NULL, 'k'},
+        {NULL, 0, NULL, 0},
+    };
+    const char short_options[] = "hk:";
+
+    int c;
+    do
+    {
+        c = getopt_long(
+            argc, (char* const*)argv, short_options, long_options, NULL);
+        if (c == -1)
+        {
+            // all the command-line options are parsed
+            break;
+        }
+
+        switch (c)
+        {
+            case 'h':
+                fprintf(stderr, _usage_signerid, argv[0]);
+                goto done;
+            case 'k':
+                keyfile = optarg;
+                break;
+            case ':':
+                // Missing option argument
+                ret = 1;
+                goto done;
+            case '?':
+            default:
+                // Invalid option
+                ret = 1;
+                goto done;
+        }
+    } while (1);
+
+    if (keyfile == NULL)
+    {
+        oe_err("--key-file option is missing");
+        ret = 1;
+    }
+    if (!ret)
+        ret = oesignerid(keyfile);
+
+done:
+
+    return ret;
+}
+
+static int _eradump_parser(int argc, const char* argv[])
+{
+    int ret = 0;
+    const char* enclave = NULL;
+
+    const struct option long_options[] = {
+        {"help", no_argument, NULL, 'h'},
+        {"enclave", required_argument, NULL, 'e'},
+        {NULL, 0, NULL, 0},
+    };
+    const char short_options[] = "he:";
+
+    int c;
+    do
+    {
+        c = getopt_long(
+            argc, (char* const*)argv, short_options, long_options, NULL);
+        if (c == -1)
+        {
+            // all the command-line options are parsed
+            break;
+        }
+
+        switch (c)
+        {
+            case 'h':
+                fprintf(stderr, _usage_eradump, argv[0]);
+                goto done;
+            case 'e':
+                enclave = optarg;
+                break;
+            case ':':
+                // Missing option argument
+                ret = 1;
+                goto done;
+            case '?':
+            default:
+                // Invalid option
+                ret = 1;
+                goto done;
+        }
+    } while (1);
+
+    if (enclave == NULL)
+    {
+        oe_err("--enclave-image option is missing");
+
+        fprintf(stderr, _usage_eradump, argv[0]);
+        ret = 1;
+    }
+
+    if (!ret)
+    {
+        ret = eradump(enclave);
+    }
+
+done:
+    return ret;
+}
+
 int arg_handler(int argc, const char* argv[])
 {
     int ret = 1;
@@ -560,6 +705,10 @@ int arg_handler(int argc, const char* argv[])
         ret = sign_parser(argc, argv);
     else if ((strcmp(argv[1], "digest") == 0))
         ret = digest_parser(argc, argv);
+    else if (strcmp(argv[1], "signerid") == 0)
+        ret = _signerid_parser(argc, argv);
+    else if (strcmp(argv[1], "eradump") == 0)
+        ret = _eradump_parser(argc, argv);
     else
     {
         fprintf(stderr, _usage_gen, argv[0], argv[0]);
diff --git a/tools/oesign/oeinfo.c b/tools/oesign/oeinfo.c
index 6e047eef5..c6957ad63 100644
--- a/tools/oesign/oeinfo.c
+++ b/tools/oesign/oeinfo.c
@@ -24,7 +24,7 @@ oe_result_t oe_read_oeinfo_sgx(
         OE_RAISE(OE_INVALID_PARAMETER);
 
     /* Load the ELF image */
-    OE_CHECK(oe_load_enclave_image(path, &oeimage));
+    OE_CHECK(oe_load_enclave_image(path, &oeimage, (void*)1));
 
     /* Load the SGX enclave properties */
     OE_CHECK(oe_sgx_load_enclave_properties(&oeimage, properties));
@@ -61,7 +61,7 @@ oe_result_t oe_write_oeinfo_sgx(
 
     /* Open ELF file */
     OE_CHECK_ERR(
-        oe_load_enclave_image(path, &oeimage),
+        oe_load_enclave_image(path, &oeimage, (void*)1),
         "Cannot load ELF file: %s",
         path);
 
diff --git a/tools/oesign/oesign.c b/tools/oesign/oesign.c
index e18456047..6c810610a 100644
--- a/tools/oesign/oesign.c
+++ b/tools/oesign/oesign.c
@@ -53,6 +53,8 @@ typedef struct _config_file_options
     optional_bool_t capture_pf_gp_exceptions;
     optional_bool_t create_zero_base_enclave;
     optional_uint64_t start_address;
+    // EDG: additional options
+    optional_bool_t executable_heap;
 } config_file_options_t;
 
 int uuid_from_string(str_t* str, uint8_t* uuid, size_t expected_size);
@@ -394,6 +396,33 @@ static int _load_config_file(const char* path, config_file_options_t* options)
             options->start_address.value = n;
             options->start_address.has_value = true;
         }
+        // EDG: executable heap
+        else if (strcmp(str_ptr(&lhs), "ExecutableHeap") == 0)
+        {
+            uint64_t value;
+
+            if (options->executable_heap.has_value)
+            {
+                oe_err(
+                    "%s(%zu): Duplicate 'ExecutableHeap' value provided",
+                    path,
+                    line);
+                goto done;
+            }
+
+            // ExecutableHeap must be 0 or 1
+            if (str_u64(&rhs, &value) != 0 || (value > 1))
+            {
+                oe_err(
+                    "%s(%zu): 'ExecutableHeap' value must be 0 or 1",
+                    path,
+                    line);
+                goto done;
+            }
+
+            options->executable_heap.value = (bool)value;
+            options->executable_heap.has_value = true;
+        }
         else
         {
             oe_err("%s(%zu): unknown setting: %s", path, line, str_ptr(&rhs));
@@ -482,7 +511,7 @@ done:
     return rc;
 }
 
-static int _load_pem_file(const char* path, void** data, size_t* size)
+int load_pem_file(const char* path, void** data, size_t* size)
 {
     int err = _load_file(path, data, size);
     if (err == 0)
@@ -579,6 +608,11 @@ void _merge_config_file_options(
     if (options->create_zero_base_enclave.value == 1 &&
         options->start_address.has_value)
         properties->config.start_address = options->start_address.value;
+
+    // EDG: executable heap
+    if (options->executable_heap.has_value)
+        properties->config.flags.executable_heap =
+            options->executable_heap.value ? 1 : 0;
 }
 
 oe_result_t _initialize_enclave_properties(
@@ -652,7 +686,8 @@ static uint64_t _map_attributes(const oe_sgx_enclave_properties_t* properties)
 oe_result_t _get_sgx_enclave_hash(
     const char* enclave,
     const oe_sgx_enclave_properties_t* properties,
-    OE_SHA256* hash)
+    OE_SHA256* hash,
+    const char* payload_path)
 {
     oe_result_t result = OE_UNEXPECTED;
     oe_enclave_t enc;
@@ -668,7 +703,7 @@ oe_result_t _get_sgx_enclave_hash(
 
     /* Build an enclave to obtain the MRENCLAVE measurement */
     OE_CHECK_ERR(
-        oe_sgx_build_enclave(&context, enclave, properties, &enc),
+        oe_sgx_build_enclave(&context, enclave, properties, &enc, payload_path),
         "oe_sgx_build_enclave(): result=%s (%#x)",
         oe_result_str(result),
         result);
@@ -725,7 +760,8 @@ int oesign(
     const char* x509,
     const char* engine_id,
     const char* engine_load_path,
-    const char* key_id)
+    const char* key_id,
+    const char* payload_path)
 {
     int ret = 1;
     oe_result_t result = OE_UNEXPECTED;
@@ -739,7 +775,8 @@ int oesign(
     OE_CHECK_NO_TRACE(
         _initialize_enclave_properties(enclave, conffile, &properties));
 
-    OE_CHECK_NO_TRACE(_get_sgx_enclave_hash(enclave, &properties, &hash));
+    OE_CHECK_NO_TRACE(
+        _get_sgx_enclave_hash(enclave, &properties, &hash, payload_path));
 
     if (engine_id)
     {
@@ -764,7 +801,7 @@ int oesign(
     else if (digest_signature)
     {
         /* Load the public key from the x509 certificate */
-        if (_load_pem_file(x509, &pem_data, &pem_size) != 0)
+        if (load_pem_file(x509, &pem_data, &pem_size) != 0)
         {
             oe_err("Failed to load file: %s", x509 ? x509 : "NULL");
             goto done;
@@ -815,7 +852,7 @@ int oesign(
     else
     {
         /* Load private key into memory */
-        if (_load_pem_file(keyfile, &pem_data, &pem_size) != 0)
+        if (load_pem_file(keyfile, &pem_data, &pem_size) != 0)
         {
             oe_err("Failed to load file: %s", keyfile ? keyfile : "NULL");
             goto done;
@@ -841,7 +878,10 @@ int oesign(
 
     /* Create signature section and write out new file */
     OE_CHECK_ERR(
-        oe_write_oeinfo_sgx(enclave, output_file, &properties),
+        oe_write_oeinfo_sgx(
+            payload_path ? payload_path : enclave,
+            output_file ? output_file : payload_path,
+            &properties),
         "oe_write_oeinfo_sgx(): result=%s (%#x)",
         oe_result_str(result),
         result);
@@ -869,7 +909,8 @@ int oedigest(const char* enclave, const char* conffile, const char* digest_file)
     OE_CHECK_NO_TRACE(
         _initialize_enclave_properties(enclave, conffile, &properties));
 
-    OE_CHECK_NO_TRACE(_get_sgx_enclave_hash(enclave, &properties, &mrenclave));
+    OE_CHECK_NO_TRACE(
+        _get_sgx_enclave_hash(enclave, &properties, &mrenclave, NULL));
 
     /* Construct the unsigned sigstruct with the MRENCLAVE and get its digest */
     OE_CHECK_ERR(
