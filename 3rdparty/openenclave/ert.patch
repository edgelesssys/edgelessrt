diff --git a/3rdparty/dlmalloc/allocator.c b/3rdparty/dlmalloc/allocator.c
index 510668721..b17909b5b 100644
--- a/3rdparty/dlmalloc/allocator.c
+++ b/3rdparty/dlmalloc/allocator.c
@@ -5,7 +5,10 @@
 #include <openenclave/advanced/mallinfo.h>
 #include <openenclave/enclave.h>
 
-#define HAVE_MMAP 0
+// EDG: use mmap instead of morecore
+#define HAVE_MMAP 1
+#define HAVE_MREMAP 0
+#define HAVE_MORECORE 0
 #define LACKS_UNISTD_H
 #define LACKS_SYS_PARAM_H
 #define LACKS_SYS_TYPES_H
@@ -14,7 +17,7 @@
 #define ABORT oe_abort()
 #define USE_DL_PREFIX
 #define LACKS_STDLIB_H
-#define LACKS_STRING_H
+//#define LACKS_STRING_H
 #define USE_LOCKS 1
 #define fprintf _dlmalloc_stats_fprintf
 #define NO_MALLOC_STATS 1
diff --git a/3rdparty/musl/CMakeLists.txt b/3rdparty/musl/CMakeLists.txt
index 01db03dbc..86ca27f3e 100644
--- a/3rdparty/musl/CMakeLists.txt
+++ b/3rdparty/musl/CMakeLists.txt
@@ -47,8 +47,6 @@ ExternalProject_Add(
   PATCH_COMMAND
   COMMAND ${CMAKE_COMMAND} -E copy ${MUSL_DIR}/arch/${ARCH}/syscall_arch.h
           ${MUSL_DIR}/arch/${ARCH}/__syscall_arch.h
-  COMMAND ${CMAKE_COMMAND} -E copy ${PATCHES_DIR}/syscall.h
-          ${MUSL_DIR}/src/internal/syscall.h
   COMMAND ${CMAKE_COMMAND} -E copy ${PATCHES_DIR}/syscall_arch.h
           ${MUSL_DIR}/arch/${ARCH}/syscall_arch.h
   COMMAND ${CMAKE_COMMAND} -E copy ${PATCHES_DIR}/pthread_${ARCH}.h
@@ -83,7 +81,8 @@ ExternalProject_Add(
   COMMAND ${CMAKE_COMMAND} -E copy ${PATCHES_DIR}/endian.h
           ${MUSL_INCLUDES}/endian.h
   # Append deprecations.h to all C header files.
-  COMMAND ${OE_BASH} -c "${MUSL_APPEND_DEPRECATIONS}"
+  # EDG: don't deprecate pthread_create and friends
+  #COMMAND ${OE_BASH} -c "${MUSL_APPEND_DEPRECATIONS}"
   # Copy local deprecations.h to include/bits/deprecated.h.
   COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_LIST_DIR}/deprecations.h
           ${MUSL_INCLUDES}/bits/deprecations.h
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 6f35184d3..ab9758da2 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -160,7 +160,8 @@ endif ()
 
 if (OE_SGX)
   # Currently we only support OpenSSL on SGX.
-  set(BUILD_OPENSSL ON)
+  # EDG: we use mbedtls only
+  #set(BUILD_OPENSSL ON)
 endif ()
 
 set(DEFAULT_TEST_ENCLAVE_CRYPTO_LIB
@@ -270,7 +271,8 @@ if (CMAKE_CXX_COMPILER_ID MATCHES "GNU" AND CMAKE_CXX_COMPILER_VERSION
                                             VERSION_LESS "7.1")
   set(COMPILER_SUPPORTS_SNMALLOC off)
 else ()
-  set(COMPILER_SUPPORTS_SNMALLOC on)
+  # EDG: no support for snmalloc yet
+  #set(COMPILER_SUPPORTS_SNMALLOC on)
 endif ()
 
 # NOTE: Building OpenEnclave using snmalloc for memory allocation is an experimental option.
@@ -403,9 +405,9 @@ add_subdirectory(tools)
 if (BUILD_ENCLAVES)
   add_subdirectory(enclave)
   add_subdirectory(3rdparty)
-  add_subdirectory(libc)
   add_subdirectory(libcxx)
   add_subdirectory(syscall)
+  add_subdirectory(${ERTSRC} ert)
 endif ()
 
 if (OE_SGX)
diff --git a/cmake/compiler_settings.cmake b/cmake/compiler_settings.cmake
index 47fa9b93f..fd1a72b9c 100644
--- a/cmake/compiler_settings.cmake
+++ b/cmake/compiler_settings.cmake
@@ -19,7 +19,7 @@ endif ()
 set(CMAKE_C_STANDARD 11)
 
 # Set the default standard to C++14 for all targets.
-set(CMAKE_CXX_STANDARD 14)
+set(CMAKE_CXX_STANDARD 17)
 set(CMAKE_CXX_STANDARD_REQUIRED ON)
 # Do not use, for example, `-std=gnu++14`.
 set(CMAKE_CXX_EXTENSIONS OFF)
diff --git a/debugger/pythonExtension/load_symbol_cmd.py b/debugger/pythonExtension/load_symbol_cmd.py
index ca0e0f893..ea04aa53b 100644
--- a/debugger/pythonExtension/load_symbol_cmd.py
+++ b/debugger/pythonExtension/load_symbol_cmd.py
@@ -89,7 +89,7 @@ def GetLoadSymbolCommand(EnclaveFile, Base):
             # Write the GDB 'add-symbol-file' command with all the arguments to the setup GDB command file.
             # Note: The mandatory argument for the 'add-symbol-file' command is the .text section without a
             # '-s .SectionName'.  All other sections need the '-s .SectionName'.
-            gdbcmd = "add-symbol-file '" + EnclaveFile + "' " + '%(Location)#08x' % {'Location':int(Out[99][2])} + " -readnow "
+            gdbcmd = "add-symbol-file '" + EnclaveFile + "' " + '%(Location)#08x' % {'Location':int(Out[99][2])} + " "
             for j in range(i):
                 gdbcmd += Out[j][0] + " " + Out[j][1] + " " + '%(Location)#08x' % {'Location' : int(Out[j][2])} + " " + Out[j][3]
         else:
diff --git a/enclave/core/init_fini.c b/enclave/core/init_fini.c
index 2c3141dba..da52fbd58 100644
--- a/enclave/core/init_fini.c
+++ b/enclave/core/init_fini.c
@@ -2,6 +2,7 @@
 // Licensed under the MIT License.
 
 #include "init_fini.h"
+#include <openenclave/ert_args.h>
 
 /*
 **==============================================================================
@@ -57,13 +58,18 @@
 
 void oe_call_init_functions(void)
 {
-    void (**fn)(void);
+    void (**fn)();
     extern void (*__init_array_start)(void);
     extern void (*__init_array_end)(void);
 
+    // EDG: Go expects args to be passed to init functions.
+    const int argc = ert_get_argc();
+    char** const argv = ert_get_argv();
+    char** const envp = ert_get_envp();
+
     for (fn = &__init_array_start; fn < &__init_array_end; fn++)
     {
-        (*fn)();
+        (*fn)(argc, argv, envp);
     }
 }
 
diff --git a/enclave/core/sgx/backtrace.c b/enclave/core/sgx/backtrace.c
index b9d64b1b4..4c5f03803 100644
--- a/enclave/core/sgx/backtrace.c
+++ b/enclave/core/sgx/backtrace.c
@@ -68,7 +68,28 @@ const void* _check_address(const void* ptr)
     if (!oe_is_within_enclave(ptr, sizeof(uint64_t)))
         return NULL;
 
-    return ptr;
+    // EDG: We must also check that ptr is not within a guard page of a thread
+    // context. See _add_data_pages() in host/sgx/create.c
+
+    const size_t num_stack_pages = oe_get_num_stack_pages();
+
+    const uintptr_t thread_contexts_start = (uintptr_t)__oe_get_heap_end();
+    const size_t thread_context_size =
+        (1 + num_stack_pages + 1 + 6) * OE_PAGE_SIZE; // see _add_data_pages()
+    const uintptr_t thread_contexts_end =
+        thread_contexts_start + oe_get_num_tcs() * thread_context_size;
+
+    const uintptr_t uptr = (uintptr_t)ptr;
+    if (!(thread_contexts_start <= uptr && uptr < thread_contexts_end))
+        return ptr;
+
+    // ptr is within thread contexts area. Check that it is within stack pages.
+    const size_t page_number =
+        (uptr - thread_contexts_start) % thread_context_size / OE_PAGE_SIZE;
+    if (1 <= page_number && page_number < 1 + num_stack_pages)
+        return ptr;
+
+    return NULL;
 }
 
 /* Safe implementation of backtrace.
diff --git a/enclave/core/sgx/calls.c b/enclave/core/sgx/calls.c
index adf260715..c9344f06e 100644
--- a/enclave/core/sgx/calls.c
+++ b/enclave/core/sgx/calls.c
@@ -46,6 +46,22 @@
 oe_result_t __oe_enclave_status = OE_OK;
 uint8_t __oe_initialized = 0;
 
+bool ert_exiting;
+
+#ifndef NDEBUG
+// EDG: initialized in _handle_ecall() and used in oe_ocall()
+static __thread void** _backtrace_buffer;
+
+oe_result_t _oe_sgx_get_backtrace_buffer_ocall(void*** _retval)
+{
+    (void)_retval;
+    return OE_UNSUPPORTED;
+}
+OE_WEAK_ALIAS(
+    _oe_sgx_get_backtrace_buffer_ocall,
+    oe_sgx_get_backtrace_buffer_ocall);
+#endif
+
 /*
 **==============================================================================
 **
@@ -178,14 +194,20 @@ static oe_result_t _handle_init_enclave(uint64_t arg_in)
             /* Initialize the OE crypto library. */
             oe_crypto_initialize();
 
-            /* Call global constructors. Now they can safely use simulated
-             * instructions like CPUID. */
-            oe_call_init_functions();
+            /* EDG: Initialize args before calling global constructors. */
+            oe_result_t ert_init_args(void);
+            OE_CHECK(ert_init_args());
 
-            /* DCLP Release barrier. */
+            /* EDG: DCLP Release barrier and set initialized before calling
+             * global constructors because they may create threads whose ecall
+             * would otherwise fail. (Go does so.) */
             OE_ATOMIC_MEMORY_BARRIER_RELEASE();
             _once = true;
             __oe_initialized = 1;
+
+            /* Call global constructors. Now they can safely use simulated
+             * instructions like CPUID. */
+            oe_call_init_functions();
         }
 
         oe_spin_unlock(&_lock);
@@ -395,6 +417,17 @@ static void _handle_ecall(
         goto done;
     }
 
+    // EDG: initialize backtrace buffer
+#ifndef NDEBUG
+    if (!_backtrace_buffer)
+    {
+        const oe_result_t res =
+            oe_sgx_get_backtrace_buffer_ocall(&_backtrace_buffer);
+        if (res != OE_OK && res != OE_UNSUPPORTED)
+            oe_abort();
+    }
+#endif
+
     /* Dispatch the ECALL */
     switch (func)
     {
@@ -405,6 +438,9 @@ static void _handle_ecall(
         }
         case OE_ECALL_DESTRUCTOR:
         {
+            /* EDG: notify that enclave is exiting */
+            ert_exiting = true;
+
             /* Call functions installed by oe_cxa_atexit() and oe_atexit() */
             oe_call_atexit_functions();
 
@@ -642,6 +678,14 @@ void oe_exit_enclave(uint64_t arg1, uint64_t arg2)
 
 oe_result_t oe_ocall(uint16_t func, uint64_t arg_in, uint64_t* arg_out)
 {
+    // EDG: trace ocalls
+#ifndef NDEBUG
+    if (_backtrace_buffer)
+        // use first array element to store size
+        *(intptr_t*)_backtrace_buffer =
+            oe_backtrace(_backtrace_buffer + 1, OE_BACKTRACE_MAX);
+#endif
+
     oe_result_t result = OE_UNEXPECTED;
     oe_sgx_td_t* td = oe_sgx_get_td();
     oe_callsite_t* callsite = td->callsites;
diff --git a/enclave/core/sgx/exception.c b/enclave/core/sgx/exception.c
index da7a16a9d..02a038e9d 100644
--- a/enclave/core/sgx/exception.c
+++ b/enclave/core/sgx/exception.c
@@ -23,6 +23,12 @@ uint32_t g_current_exception_handler_count = 0;
 oe_vectored_exception_handler_t
     g_exception_handler_arr[MAX_EXCEPTION_HANDLER_COUNT];
 
+// EDG: enclave dev can enable SIGSEGV by overriding this symbol
+OE_WEAK bool ert_enable_sigsegv;
+
+__thread uint64_t ert_sigaltstack_sp;
+static __thread uint64_t _original_sp;
+
 oe_result_t oe_add_vectored_exception_handler(
     bool is_first_handler,
     oe_vectored_exception_handler_t vectored_handler)
@@ -237,6 +243,10 @@ int _emulate_illegal_instruction(sgx_ssa_gpr_t* ssa_gpr)
 */
 void oe_real_exception_dispatcher(oe_context_t* oe_context)
 {
+    // EDG: restore sp if sigaltstack has been used
+    if (ert_sigaltstack_sp)
+        oe_context->rsp = _original_sp;
+
     oe_sgx_td_t* td = oe_sgx_get_td();
 
     // Change the rip of oe_context to the real exception address.
@@ -322,8 +332,15 @@ void oe_virtual_exception_dispatcher(
     if (!ssa_gpr->exit_info.as_fields.valid)
     {
         // Not a valid/expected enclave exception;
-        *arg_out = OE_EXCEPTION_CONTINUE_SEARCH;
-        return;
+        if (!(ert_enable_sigsegv && arg_in == 11)) // EDG: allow SIGSEGV
+        {
+            *arg_out = OE_EXCEPTION_CONTINUE_SEARCH;
+            return;
+        }
+        sgx_exit_info* const ei = &ssa_gpr->exit_info;
+        ei->as_fields.vector = 13; // #GP
+        ei->as_fields.exit_type = SGX_EXIT_TYPE_HARDWARE;
+        ei->as_fields.valid = 1;
     }
 
     // Get the exception address, code, and flags.
@@ -367,6 +384,13 @@ void oe_virtual_exception_dispatcher(
         // Modify the ssa_gpr so that e_resume will go to second pass exception
         // handler.
         ssa_gpr->rip = (uint64_t)oe_exception_dispatcher;
+
+        // EDG: use alternative sp if sigaltstack has been used
+        if (ert_sigaltstack_sp)
+        {
+            _original_sp = ssa_gpr->rsp;
+            ssa_gpr->rsp = ert_sigaltstack_sp;
+        }
     }
 
     // Cleanup the exception flag to avoid the exception handler is called
diff --git a/enclave/core/sgx/globals.c b/enclave/core/sgx/globals.c
index 06902fffd..fca0a649d 100644
--- a/enclave/core/sgx/globals.c
+++ b/enclave/core/sgx/globals.c
@@ -156,6 +156,11 @@ const void* __oe_get_enclave_elf_header(void)
     return __oe_get_enclave_base();
 }
 
+uint64_t oe_get_num_tcs(void)
+{
+    return oe_enclave_properties_sgx.header.size_settings.num_tcs;
+}
+
 /*
 **==============================================================================
 **
@@ -269,3 +274,22 @@ uint64_t oe_get_num_pages(void)
 {
     return __oe_get_enclave_size() / OE_PAGE_SIZE;
 }
+
+/*
+**==============================================================================
+**
+** Stack:
+**
+**==============================================================================
+*/
+
+size_t oe_get_num_stack_pages(void)
+{
+    return oe_enclave_properties_sgx.header.size_settings.num_stack_pages;
+}
+
+size_t oe_get_stack_size(void)
+{
+    return oe_enclave_properties_sgx.header.size_settings.num_stack_pages *
+           OE_PAGE_SIZE;
+}
diff --git a/enclave/core/sgx/keys.c b/enclave/core/sgx/keys.c
index 28e78c546..23acc8d09 100644
--- a/enclave/core/sgx/keys.c
+++ b/enclave/core/sgx/keys.c
@@ -31,6 +31,22 @@ static oe_result_t _get_key_imp(
     sgx_key_request_t tmp_key_request = *sgx_key_request;
     OE_ALIGNED(SGX_KEY_ALIGNMENT) sgx_key_t tmp_sgx_key;
 
+    // EDG: return test key in simulation mode
+    if (oe_sgx_get_td()->simulate)
+    {
+        // satisfy unit test
+        if (tmp_key_request.key_name != SGX_KEYSELECT_REPORT &&
+            tmp_key_request.key_name != SGX_KEYSELECT_SEAL)
+            return OE_INVALID_KEYNAME;
+        if (tmp_key_request.isv_svn)
+            return OE_INVALID_ISVSVN;
+        if (*tmp_key_request.cpu_svn)
+            return OE_INVALID_CPUSVN;
+
+        *sgx_key = (sgx_key_t){0};
+        return OE_OK;
+    }
+
     // Execute EGETKEY instruction.
     egetkey_result = oe_egetkey(&tmp_key_request, &tmp_sgx_key);
 
@@ -193,10 +209,11 @@ static oe_result_t _get_default_key_request_attributes(
 {
     sgx_report_t sgx_report = {{{0}}};
 
-    oe_result_t result;
+    oe_result_t result = OE_OK;
 
     // Get a local report of current enclave.
-    result = sgx_create_report(NULL, 0, NULL, 0, &sgx_report);
+    if (!oe_sgx_get_td()->simulate) // EDG: skip in simulation mode
+        result = sgx_create_report(NULL, 0, NULL, 0, &sgx_report);
 
     if (result != OE_OK)
     {
diff --git a/enclave/core/sgx/threadlocal.c b/enclave/core/sgx/threadlocal.c
index cbb4f535c..a8e77c2f8 100644
--- a/enclave/core/sgx/threadlocal.c
+++ b/enclave/core/sgx/threadlocal.c
@@ -374,8 +374,10 @@ done:
 /**
  * Register a destructor to be called on the given object when the
  * thread exits. This call is emitted by the compiler.
+ *
+ * EDG: renamed from __cxa_thread_atexit
  */
-void __cxa_thread_atexit(void (*destructor)(void*), void* object)
+void __cxa_thread_atexit_impl(void (*destructor)(void*), void* object)
 {
     oe_sgx_td_t* td = oe_sgx_get_td();
 
@@ -391,6 +393,11 @@ void __cxa_thread_atexit(void (*destructor)(void*), void* object)
     td->tls_atexit_functions[td->num_tls_atexit_functions - 1] = item;
 }
 
+// EDG: stdc++ defines __cxa_thread_atexit which calls
+// __cxa_thread_atexit_impl. So behavior will be the same whether or not stdc++
+// is linked.
+OE_WEAK_ALIAS(__cxa_thread_atexit_impl, __cxa_thread_atexit);
+
 /**
  * Cleanup the thread-local section for a given thread.
  * This must be called *before* the td itself is cleaned up.
diff --git a/host/CMakeLists.txt b/host/CMakeLists.txt
index 229a0d06b..d6330f662 100644
--- a/host/CMakeLists.txt
+++ b/host/CMakeLists.txt
@@ -340,10 +340,16 @@ list(
   strings.c
   traceh_enclave.c)
 
+# EDG: add erthost
+include(${ERTSRC}/host/erthost.cmake)
+
 # Combine the following common code along with the platform specific code and
 # host verification code to get the full oehost target provided by the OE SDK.
 add_library(oehost STATIC ${PLATFORM_HOST_ONLY_SRC} ${PLATFORM_SDK_ONLY_SRC})
 
+# EDG: add EDL
+add_dependencies(oehost ertlibc_untrusted_edl)
+
 add_library(oehostverify STATIC ${PLATFORM_HOST_ONLY_SRC})
 
 target_link_libraries(oehostverify PUBLIC oe_includes)
@@ -466,7 +472,8 @@ endif ()
 if (UNIX)
   target_compile_options(
     oehost
-    PRIVATE -Wno-attributes -Wmissing-prototypes -fPIC ${PLATFORM_FLAGS}
+    PRIVATE -Wno-attributes $<$<COMPILE_LANGUAGE:C>:-Wmissing-prototypes> -fPIC
+            ${PLATFORM_FLAGS}
     PUBLIC -fstack-protector-strong)
   target_compile_definitions(
     oehost
@@ -483,7 +490,8 @@ if (UNIX)
 endif ()
 
 if (CMAKE_C_COMPILER_ID MATCHES GNU)
-  target_compile_options(oehost PRIVATE -Wjump-misses-init)
+  target_compile_options(oehost
+                         PRIVATE $<$<COMPILE_LANGUAGE:C>:-Wjump-misses-init>)
   target_compile_options(oehostverify PRIVATE -Wjump-misses-init)
 endif ()
 
diff --git a/host/linux/syscall.c b/host/linux/syscall.c
index 9056f92d3..676033c5c 100644
--- a/host/linux/syscall.c
+++ b/host/linux/syscall.c
@@ -1270,11 +1270,15 @@ int oe_syscall_poll_ocall(
 
     errno = 0;
 
+// EDG: poll with nfds=0 can be used as sleep. (Python uses it this way and it
+// is also documented in the manpage.)
+#if 0
     if (nfds == 0)
     {
         errno = EINVAL;
         goto done;
     }
+#endif
 
     if (!(fds = calloc(nfds, sizeof(struct oe_pollfd))))
     {
diff --git a/host/sgx/calls.c b/host/sgx/calls.c
index 449af159e..6c2b8d6a4 100644
--- a/host/sgx/calls.c
+++ b/host/sgx/calls.c
@@ -36,6 +36,8 @@
 #include "enclave.h"
 #include "ocalls/ocalls.h"
 
+void ert_trace_ocall(oe_enclave_t* enclave, const void* func);
+
 /*
 **==============================================================================
 **
@@ -245,6 +247,8 @@ oe_result_t oe_handle_call_host_function(uint64_t arg, oe_enclave_t* enclave)
         goto done;
     }
 
+    ert_trace_ocall(enclave, func);
+
     OE_CHECK(oe_safe_add_u64(
         args_ptr->input_buffer_size,
         args_ptr->output_buffer_size,
@@ -356,22 +360,27 @@ static oe_result_t _handle_ocall(
             break;
 
         case OE_OCALL_MALLOC:
+            ert_trace_ocall(enclave, HandleMalloc);
             HandleMalloc(arg_in, arg_out);
             break;
 
         case OE_OCALL_FREE:
+            ert_trace_ocall(enclave, HandleFree);
             HandleFree(arg_in);
             break;
 
         case OE_OCALL_THREAD_WAIT:
+            ert_trace_ocall(enclave, HandleThreadWait);
             HandleThreadWait(enclave, arg_in);
             break;
 
         case OE_OCALL_THREAD_WAKE:
+            ert_trace_ocall(enclave, HandleThreadWake);
             HandleThreadWake(enclave, arg_in);
             break;
 
         case OE_OCALL_GET_TIME:
+            ert_trace_ocall(enclave, oe_handle_get_time);
             oe_handle_get_time(arg_in, arg_out);
             break;
 
@@ -382,6 +391,10 @@ static oe_result_t _handle_ocall(
         }
     }
 
+    // EDG: Insert cancellation point after ocall (esp. after THREAD_WAIT) so
+    // that EnclaveThreadManager is able to cancel enclave threads.
+    pthread_testcancel();
+
     result = OE_OK;
 
 done:
diff --git a/host/sgx/create.c b/host/sgx/create.c
index fa2f97e85..22dd0843b 100644
--- a/host/sgx/create.c
+++ b/host/sgx/create.c
@@ -772,7 +772,8 @@ oe_result_t oe_sgx_build_enclave(
     oe_sgx_load_context_t* context,
     const char* path,
     const oe_sgx_enclave_properties_t* properties,
-    oe_enclave_t* enclave)
+    oe_enclave_t* enclave,
+    const char* payload_path)
 {
     oe_result_t result = OE_UNEXPECTED;
     size_t loaded_enclave_pages_size = 0;
@@ -784,6 +785,7 @@ oe_result_t oe_sgx_build_enclave(
     size_t tls_page_count;
     uint64_t vaddr = 0;
     oe_sgx_enclave_properties_t props;
+    oe_enclave_image_t oeimage_payload = {0};
 
     if (!enclave)
         OE_RAISE(OE_INVALID_PARAMETER);
@@ -832,6 +834,37 @@ oe_result_t oe_sgx_build_enclave(
             sizeof(props));
     }
 
+    // EDG: load payload image
+    if (payload_path)
+    {
+        OE_CHECK(oe_load_enclave_image(payload_path, &oeimage_payload));
+        context->payload_image_size = oeimage_payload.elf.image_size;
+        context->payload_reloc_size = oeimage_payload.elf.reloc_size;
+
+        // use props from payload
+        if (properties)
+            memcpy(
+                oeimage_payload.elf.image_base + oeimage_payload.elf.oeinfo_rva,
+                &props,
+                sizeof(props));
+        else
+        {
+            memcpy(
+                &props,
+                oeimage_payload.elf.image_base + oeimage_payload.elf.oeinfo_rva,
+                sizeof(props));
+            memcpy(
+                oeimage.elf.image_base + oeimage.elf.oeinfo_rva,
+                &props,
+                sizeof(props));
+        }
+
+        // Clear the hash when taking the measure
+        oe_sgx_enclave_properties_t* const props_payload =
+        (oe_sgx_enclave_properties_t*)(oeimage_payload.elf.image_base + oeimage_payload.elf.oeinfo_rva);
+        memset(props_payload->sigstruct, 0, sizeof(props_payload->sigstruct));
+    }
+
     /* Validate the enclave prop_override structure */
     OE_CHECK(oe_sgx_validate_enclave_properties(&props, NULL));
 
@@ -868,7 +901,8 @@ oe_result_t oe_sgx_build_enclave(
 
     /* Calculate the size of this enclave in memory */
     OE_CHECK(_calculate_enclave_size(
-        image_size,
+        image_size + oeimage_payload.elf.image_size +
+            oeimage_payload.elf.reloc_size,
         tls_page_count,
         &props,
         &loaded_enclave_pages_size,
@@ -902,6 +936,9 @@ oe_result_t oe_sgx_build_enclave(
 
     /* Add image to enclave */
     OE_CHECK(oeimage.add_pages(&oeimage, context, enclave, &vaddr));
+    if (payload_path)
+        OE_CHECK(oeimage_payload.add_pages(
+            &oeimage_payload, context, enclave, &vaddr));
 
 #ifdef OE_WITH_EXPERIMENTAL_EEID
     OE_CHECK(_add_eeid_marker_page(
@@ -1084,8 +1121,20 @@ oe_result_t oe_create_enclave(
         }
 #endif
 
-    /* Build the enclave */
-    OE_CHECK(oe_sgx_build_enclave(&context, enclave_path, NULL, enclave));
+    // EDG: split enclave_path which is either "main_image" or
+    // "main_image:payload_image"
+    if (!*enclave_path)
+        OE_RAISE(OE_FAILURE);
+    {
+        char* const paths = strdup(enclave_path);
+        enclave_path = strtok(paths, ":");
+        const char* const payload_path = strtok(NULL, ":");
+
+        /* Build the enclave */
+        OE_CHECK(oe_sgx_build_enclave(
+            &context, enclave_path, NULL, enclave, payload_path));
+        free(paths);
+    }
 
     /* Push the new created enclave to the global list. */
     if (oe_push_enclave_instance(enclave) != 0)
@@ -1185,6 +1234,10 @@ oe_result_t oe_terminate_enclave(oe_enclave_t* enclave)
     /* Shut down the switchless manager */
     OE_CHECK(oe_stop_switchless_manager(enclave));
 
+    /* EDG: cancel lingering threads (if any) */
+    oe_result_t ert_cancel_threads_created_inside_enclave(oe_enclave_t*);
+    OE_CHECK(ert_cancel_threads_created_inside_enclave(enclave));
+
     /* Call the enclave destructor */
     OE_CHECK(oe_ecall(enclave, OE_ECALL_DESTRUCTOR, 0, NULL));
 
diff --git a/host/sgx/exception.c b/host/sgx/exception.c
index e908e9f9a..e8c81440a 100644
--- a/host/sgx/exception.c
+++ b/host/sgx/exception.c
@@ -46,8 +46,11 @@ uint64_t oe_host_handle_exception(oe_host_exception_context_t* context)
 
         // Call into enclave first pass exception handler.
         uint64_t arg_out = 0;
-        oe_result_t result =
-            oe_ecall(enclave, OE_ECALL_VIRTUAL_EXCEPTION_HANDLER, 0, &arg_out);
+        oe_result_t result = oe_ecall(
+            enclave,
+            OE_ECALL_VIRTUAL_EXCEPTION_HANDLER,
+            (uint64_t)context->sig_num,
+            &arg_out);
 
         // Reset the flag
         thread_data->flags &= (~_OE_THREAD_HANDLING_EXCEPTION);
diff --git a/host/sgx/exception.h b/host/sgx/exception.h
index 0552194e7..a86ad4800 100644
--- a/host/sgx/exception.h
+++ b/host/sgx/exception.h
@@ -12,6 +12,7 @@ typedef struct _host_exception_context
     uint64_t rax;
     uint64_t rbx;
     uint64_t rip;
+    int sig_num;
 } oe_host_exception_context_t;
 
 /* Initialize the exception processing. */
diff --git a/host/sgx/linux/exception.c b/host/sgx/linux/exception.c
index 6242e15f5..300d50a8c 100644
--- a/host/sgx/linux/exception.c
+++ b/host/sgx/linux/exception.c
@@ -37,6 +37,7 @@ static void _host_signal_handler(
     host_context.rax = (uint64_t)context->uc_mcontext.gregs[REG_RAX];
     host_context.rbx = (uint64_t)context->uc_mcontext.gregs[REG_RBX];
     host_context.rip = (uint64_t)context->uc_mcontext.gregs[REG_RIP];
+    host_context.sig_num = sig_num;
 
     // Call platform neutral handler.
     uint64_t action = oe_host_handle_exception(&host_context);
diff --git a/host/sgx/loadelf.c b/host/sgx/loadelf.c
index e49b6e8e8..c4050c565 100644
--- a/host/sgx/loadelf.c
+++ b/host/sgx/loadelf.c
@@ -573,7 +573,9 @@ static oe_result_t _add_segment_pages(
     oe_sgx_load_context_t* context,
     uint64_t enclave_addr,
     const oe_elf_segment_t* segment,
-    void* image)
+    void* image,
+    uint64_t vaddr) // EDG: added vaddr param so that this function can also be
+                    // used for the payload image which is not at vaddr 0
 {
     oe_result_t result = OE_UNEXPECTED;
     uint64_t flags;
@@ -602,7 +604,7 @@ static oe_result_t _add_segment_pages(
         OE_CHECK(oe_sgx_load_enclave_data(
             context,
             enclave_addr,
-            enclave_addr + page_rva,
+            enclave_addr + vaddr + page_rva,
             (uint64_t)image + page_rva,
             flags,
             true));
@@ -625,7 +627,7 @@ static oe_result_t _add_elf_image_pages(
     assert(context);
     assert(enclave);
     assert(image);
-    assert(vaddr && (*vaddr == 0));
+    assert(vaddr);
     assert((image->image_size & (OE_PAGE_SIZE - 1)) == 0);
     assert(enclave->size > image->image_size);
 
@@ -633,10 +635,14 @@ static oe_result_t _add_elf_image_pages(
     for (size_t i = 0; i < image->num_segments; i++)
     {
         OE_CHECK(_add_segment_pages(
-            context, enclave->addr, &image->segments[i], image->image_base));
+            context,
+            enclave->addr,
+            &image->segments[i],
+            image->image_base,
+            *vaddr));
     }
 
-    *vaddr = image->image_size;
+    *vaddr += image->image_size;
 
     /* Add the relocation pages (contain relocation entries) */
     OE_CHECK(_add_relocation_pages(
@@ -748,9 +754,21 @@ static oe_result_t _patch_elf_image(
         image, "_reloc_rva", image->image_size));
     OE_CHECK(_set_uint64_t_dynamic_symbol_value(
         image, "_reloc_size", image->reloc_size));
+    if (context->payload_image_size)
+    {
+        OE_CHECK(_set_uint64_t_dynamic_symbol_value(
+            image,
+            "_payload_reloc_rva",
+            image->image_size + image->reloc_size +
+                context->payload_image_size));
+        OE_CHECK(_set_uint64_t_dynamic_symbol_value(
+            image, "_payload_reloc_size", context->payload_reloc_size));
+    }
 
     /* heap right after image */
-    oeprops->image_info.heap_rva = image->image_size + image->reloc_size;
+    oeprops->image_info.heap_rva = image->image_size + image->reloc_size +
+                                   context->payload_image_size +
+                                   context->payload_reloc_size;
 
     if (image->tdata_size)
     {
diff --git a/include/openenclave/edl/sgx/debug.edl b/include/openenclave/edl/sgx/debug.edl
index 7b86fc8b8..89d2643bc 100644
--- a/include/openenclave/edl/sgx/debug.edl
+++ b/include/openenclave/edl/sgx/debug.edl
@@ -29,5 +29,7 @@ enclave
             [out, size=symbols_buffer_size] void* symbols_buffer,
             size_t symbols_buffer_size,
             [out] size_t* symbols_buffer_size_out);
+
+        void** oe_sgx_get_backtrace_buffer_ocall();
     };
 };
diff --git a/include/openenclave/edl/sgx/thread.edl b/include/openenclave/edl/sgx/thread.edl
index af2f301b0..a278851fe 100644
--- a/include/openenclave/edl/sgx/thread.edl
+++ b/include/openenclave/edl/sgx/thread.edl
@@ -17,11 +17,27 @@ enclave
     // intentionally kept in host memory.
     include "openenclave/bits/types.h"
 
+    struct oe_sgx_thread_timedwait_ocall_timespec
+    {
+        time_t tv_sec;
+        long tv_nsec;
+    };
+
     untrusted
     {
         void oe_sgx_thread_wake_wait_ocall(
             [user_check] oe_enclave_t* oe_enclave,
             uint64_t waiter_tcs,
             uint64_t self_tcs);
+
+        int oe_sgx_thread_timedwait_ocall(
+            [user_check] oe_enclave_t* oe_enclave,
+            uint64_t tcs,
+            [in] const struct oe_sgx_thread_timedwait_ocall_timespec* timeout);
+
+        void oe_sgx_thread_wake_multiple_ocall(
+            [user_check] oe_enclave_t* oe_enclave,
+            [in, count=tcs_size] const uint64_t* tcs,
+            size_t tcs_size);
     };
 };
diff --git a/include/openenclave/edl/syscall.edl b/include/openenclave/edl/syscall.edl
index 38f075434..7b7a083f7 100644
--- a/include/openenclave/edl/syscall.edl
+++ b/include/openenclave/edl/syscall.edl
@@ -30,4 +30,11 @@ enclave {
     from "openenclave/edl/time.edl" import *;
     from "openenclave/edl/unistd.edl" import *;
     from "openenclave/edl/utsname.edl" import *;
+
+    untrusted {
+        oe_host_fd_t oe_syscall_eventfd_ocall(
+            unsigned int initval,
+            int flags)
+            propagate_errno;
+    };
 };
diff --git a/include/openenclave/host.h b/include/openenclave/host.h
index 23017cd2b..3407398b9 100644
--- a/include/openenclave/host.h
+++ b/include/openenclave/host.h
@@ -204,6 +204,18 @@ oe_result_t oe_create_enclave(
     uint32_t ecall_count,
     oe_enclave_t** enclave);
 
+/**
+ * Join all threads that have been created from inside the enclave.
+ *
+ * This function should be called before **oe_terminate_enclave()**.
+ *
+ * @param enclave The instance of the enclave whose threads should be joined.
+ *
+ * @returns Returns OE_OK on success.
+ *
+ */
+oe_result_t ert_join_threads_created_inside_enclave(oe_enclave_t* enclave);
+
 /**
  * Terminate an enclave and reclaims its resources.
  *
diff --git a/include/openenclave/internal/globals.h b/include/openenclave/internal/globals.h
index 986fd0b61..3b5f7723e 100644
--- a/include/openenclave/internal/globals.h
+++ b/include/openenclave/internal/globals.h
@@ -14,6 +14,7 @@ OE_EXTERNC_BEGIN
 const void* __oe_get_enclave_base(void);
 size_t __oe_get_enclave_size(void);
 const void* __oe_get_enclave_elf_header(void);
+uint64_t oe_get_num_tcs(void);
 
 /* Reloc */
 const void* __oe_get_reloc_base(void);
@@ -37,6 +38,10 @@ uint64_t oe_get_num_pages(void);
 const void* __oe_get_eeid(void);
 #endif
 
+/* Stack */
+size_t oe_get_num_stack_pages(void);
+size_t oe_get_stack_size(void);
+
 OE_EXTERNC_END
 
 #endif /* _OE_GLOBALS_H */
diff --git a/include/openenclave/internal/sgxcreate.h b/include/openenclave/internal/sgxcreate.h
index 24749af7a..46dec043c 100644
--- a/include/openenclave/internal/sgxcreate.h
+++ b/include/openenclave/internal/sgxcreate.h
@@ -65,6 +65,10 @@ struct _oe_sgx_load_context
     /* EEID data needed during enclave creation */
     oe_eeid_t* eeid;
 #endif
+
+    // EDG: payload properties
+    size_t payload_image_size;
+    size_t payload_reloc_size;
 };
 
 oe_result_t oe_sgx_initialize_load_context(
@@ -78,7 +82,8 @@ oe_result_t oe_sgx_build_enclave(
     oe_sgx_load_context_t* context,
     const char* path,
     const oe_sgx_enclave_properties_t* properties,
-    oe_enclave_t* enclave);
+    oe_enclave_t* enclave,
+    const char* payload_path);
 
 /**
  * Validate certain fields of an SGX enclave properties structure.
diff --git a/include/openenclave/internal/syscall/device.h b/include/openenclave/internal/syscall/device.h
index fc9a2806c..33afd42b2 100644
--- a/include/openenclave/internal/syscall/device.h
+++ b/include/openenclave/internal/syscall/device.h
@@ -31,6 +31,9 @@ enum
 
     /* The host epoll device. */
     OE_DEVID_HOST_EPOLL,
+
+    /* Base id for custom devices. Must be last. */
+    OE_DEVID_CUSTOM,
 };
 
 /* Device names. */
@@ -151,6 +154,9 @@ oe_device_t* oe_device_table_find(const char* name, oe_device_type_t type);
 /* Remove the given device from the table and call its release() method. */
 int oe_device_table_remove(uint64_t devid);
 
+/* Get a unique id for a custom device. */
+uint64_t oe_device_table_get_custom_devid(void);
+
 /**
  * Associate a device id with the current thread.
  *
diff --git a/include/openenclave/internal/syscall/raise.h b/include/openenclave/internal/syscall/raise.h
index 5f328735d..6c15cb5c4 100644
--- a/include/openenclave/internal/syscall/raise.h
+++ b/include/openenclave/internal/syscall/raise.h
@@ -16,7 +16,7 @@ OE_EXTERNC_BEGIN
     do                                                         \
     {                                                          \
         int __err = ERRNO;                                     \
-        oe_log(OE_LOG_LEVEL_ERROR, "oe_errno=%d [%s %s:%d]\n", \
+        oe_log(OE_LOG_LEVEL_WARNING, "oe_errno=%d [%s %s:%d]\n", \
             __err, __FILE__, __FUNCTION__, __LINE__);          \
         oe_errno = __err;                                      \
         goto done;                                             \
@@ -29,7 +29,7 @@ OE_EXTERNC_BEGIN
     do                                                              \
     {                                                               \
         int __err = ERRNO;                                          \
-        oe_log(OE_LOG_LEVEL_ERROR, FMT " oe_errno=%d [%s %s:%d]\n", \
+        oe_log(OE_LOG_LEVEL_WARNING, FMT " oe_errno=%d [%s %s:%d]\n", \
            ##__VA_ARGS__, __err, __FILE__, __FUNCTION__, __LINE__); \
         oe_errno = __err;                                           \
         goto done;                                                  \
diff --git a/include/openenclave/internal/syscall/unistd.h b/include/openenclave/internal/syscall/unistd.h
index e541e8aa0..70ba3fd5e 100644
--- a/include/openenclave/internal/syscall/unistd.h
+++ b/include/openenclave/internal/syscall/unistd.h
@@ -9,6 +9,7 @@
 #include <openenclave/bits/types.h>
 #include <openenclave/corelibc/bits/types.h>
 #include <openenclave/corelibc/stdarg.h>
+#include <openenclave/internal/syscall/types.h>
 #include <openenclave/internal/syscall/unistd.h>
 
 OE_EXTERNC_BEGIN
@@ -74,6 +75,8 @@ int oe_chdir(const char* path);
 
 int oe_close(int fd);
 
+int oe_close_hostfd(oe_host_fd_t fd);
+
 int oe_gethostname(char* name, size_t len);
 
 int oe_getdomainname(char* name, size_t len);
diff --git a/pkgconfig/CMakeLists.txt b/pkgconfig/CMakeLists.txt
index f974de571..4b40bf9c5 100644
--- a/pkgconfig/CMakeLists.txt
+++ b/pkgconfig/CMakeLists.txt
@@ -86,7 +86,7 @@ set(ENCLAVE_MBEDTLS_CRYPTO_WRAPPER_LIBS -loecryptombedtls -lmbedx509 -lmbedtls
 set(ENCLAVE_OPENSSL_CRYPTO_WRAPPER_LIBS -loecryptoopenssl -lopensslssl
                                         -lopensslcrypto)
 
-set(ENCLAVE_CLIBS_2 -loelibc -loesyscall -loecore)
+set(ENCLAVE_CLIBS_2 -loelibc -loesyscall -loelibc -loecore)
 
 set(ENCLAVE_CLIBS_LIST ${ENCLAVE_CLIBS_1} ${ENCLAVE_CLIBS_2})
 list(JOIN ENCLAVE_CLIBS_LIST " " ENCLAVE_CLIBS)
diff --git a/samples/attested_tls/client/enc/Makefile b/samples/attested_tls/client/enc/Makefile
index 116626d70..ee67fef34 100644
--- a/samples/attested_tls/client/enc/Makefile
+++ b/samples/attested_tls/client/enc/Makefile
@@ -31,7 +31,7 @@ build:
 
 	$(CXX) -g -c $(CXXFLAGS) $(INCLUDES) -I. -std=c++11 $(SRC_FILES)
 	$(CC) -c $(CFLAGS) $(CINCLUDES) -I. ./tls_client_t.c
-	$(CXX) -o tls_client_enclave $(OBJ_FILES) $(LDFLAGS) $(CRYPTO_LDFLAGS) -loehostsock -loehostresolver
+	$(CXX) -o tls_client_enclave $(OBJ_FILES) $(LDFLAGS) $(CRYPTO_LDFLAGS) -loehostsock -loehostresolver -loecore
 
 sign:
 	oesign sign -e tls_client_enclave -c  enc.conf -k private.pem
diff --git a/samples/attested_tls/server/enc/Makefile b/samples/attested_tls/server/enc/Makefile
index 91438ba5d..f37a442e5 100644
--- a/samples/attested_tls/server/enc/Makefile
+++ b/samples/attested_tls/server/enc/Makefile
@@ -33,7 +33,7 @@ build:
 
 	$(CXX) -g -c $(CXXFLAGS) $(INCLUDES) -I. -std=c++11 ${SRC_FILES}
 	$(CC) -c $(CFLAGS) $(CINCLUDES) -I. tls_server_t.c
-	$(CXX) -o tls_server_enc $(OBJ_FILES) $(LDFLAGS) $(CRYPTO_LDFLAGS) -loehostsock -loehostresolver
+	$(CXX) -o tls_server_enc $(OBJ_FILES) $(LDFLAGS) $(CRYPTO_LDFLAGS) -loehostsock -loehostresolver -loecore
 
 sign:
 	oesign sign -e tls_server_enc -c enc.conf -k private.pem
diff --git a/samples/debugmalloc/host/Makefile b/samples/debugmalloc/host/Makefile
index 7ea4266a4..b18a70159 100644
--- a/samples/debugmalloc/host/Makefile
+++ b/samples/debugmalloc/host/Makefile
@@ -14,7 +14,7 @@ build:
 		--search-path $(INCDIR)/openenclave/edl/sgx
 	$(CC) -g -c $(CFLAGS) host.c
 	$(CC) -g -c $(CFLAGS) debugmalloc_u.c
-	$(CC) -o debugmallochost debugmalloc_u.o host.o $(LDFLAGS)
+	$(CXX) -o debugmallochost debugmalloc_u.o host.o $(LDFLAGS)
 
 clean:
 	rm -f debugmallochost host.o debugmalloc_u.o debugmalloc_u.c debugmalloc_u.h debugmalloc_args.h
diff --git a/samples/helloworld/host/Makefile b/samples/helloworld/host/Makefile
index 7b3c2c2ec..29bcd0c44 100644
--- a/samples/helloworld/host/Makefile
+++ b/samples/helloworld/host/Makefile
@@ -14,7 +14,7 @@ build:
 		--search-path $(INCDIR)/openenclave/edl/sgx
 	$(CC) -g -c $(CFLAGS) host.c
 	$(CC) -g -c $(CFLAGS) helloworld_u.c
-	$(CC) -o helloworldhost helloworld_u.o host.o $(LDFLAGS)
+	$(CXX) -o helloworldhost helloworld_u.o host.o $(LDFLAGS)
 
 clean:
 	rm -f helloworldhost host.o helloworld_u.o helloworld_u.c helloworld_u.h helloworld_args.h
diff --git a/samples/log_callback/host/Makefile b/samples/log_callback/host/Makefile
index 3725ed9cc..4b3bdd695 100644
--- a/samples/log_callback/host/Makefile
+++ b/samples/log_callback/host/Makefile
@@ -14,7 +14,7 @@ build:
 		--search-path $(INCDIR)/openenclave/edl/sgx
 	$(CC) -g -c $(CFLAGS) host.c
 	$(CC) -g -c $(CFLAGS) log_callback_u.c
-	$(CC) -o log_callbackhost log_callback_u.o host.o $(LDFLAGS)
+	$(CXX) -o log_callbackhost log_callback_u.o host.o $(LDFLAGS)
 
 clean:
 	rm -f log_callbackhost host.o log_callback_u.o log_callback_u.c log_callback_u.h log_callback_args.h
diff --git a/samples/switchless/host/Makefile b/samples/switchless/host/Makefile
index 234aa640b..5e8043871 100644
--- a/samples/switchless/host/Makefile
+++ b/samples/switchless/host/Makefile
@@ -14,7 +14,7 @@ build:
 		--search-path $(INCDIR)/openenclave/edl/sgx
 	$(CC) -g -c $(CFLAGS) host.c
 	$(CC) -g -c $(CFLAGS) switchless_sample_u.c
-	$(CC) -o switchlesshost switchless_sample_u.o host.o $(LDFLAGS)
+	$(CXX) -o switchlesshost switchless_sample_u.o host.o $(LDFLAGS)
 
 clean:
 	rm -f switchlesshost host.o switchless_sample_u.o \
diff --git a/samples/test-samples.cmake b/samples/test-samples.cmake
index 87920e529..34aa3f807 100644
--- a/samples/test-samples.cmake
+++ b/samples/test-samples.cmake
@@ -71,8 +71,8 @@ else ()
     # These tests can only run with SGX-FLC, meaning they were built
     # against SGX.
     if (HAS_QUOTE_PROVIDER)
-      list(APPEND SAMPLES_LIST attested_tls attested_tls attestation)
-      list(APPEND CRYPTO_LIB_LIST mbedtls openssl mbedtls)
+      list(APPEND SAMPLES_LIST attested_tls attestation)
+      list(APPEND CRYPTO_LIB_LIST mbedtls mbedtls)
     endif ()
   endif ()
 endif ()
diff --git a/syscall/CMakeLists.txt b/syscall/CMakeLists.txt
index e69e9d848..4e19b7ec8 100644
--- a/syscall/CMakeLists.txt
+++ b/syscall/CMakeLists.txt
@@ -66,7 +66,7 @@ enclave_include_directories(
   oesyscall PRIVATE ${CMAKE_CURRENT_SOURCE_DIR} ${CMAKE_CURRENT_BINARY_DIR}
   ${PROJECT_SOURCE_DIR}/include/openenclave/corelibc)
 
-enclave_link_libraries(oesyscall PUBLIC oecore)
+enclave_link_libraries(oesyscall PUBLIC oecore PRIVATE oelibc)
 enclave_compile_options(oesyscall PRIVATE -ffunction-sections)
 
 set_source_files_properties(${CMAKE_CURRENT_BINARY_DIR}/syscall_t.c
diff --git a/syscall/device.c b/syscall/device.c
index 1cb00423c..63664a178 100644
--- a/syscall/device.c
+++ b/syscall/device.c
@@ -270,6 +270,12 @@ done:
     return ret;
 }
 
+uint64_t oe_device_table_get_custom_devid(void)
+{
+    static uint64_t id;
+    return OE_DEVID_CUSTOM + __atomic_fetch_add(&id, 1, __ATOMIC_SEQ_CST);
+}
+
 /*
 **==============================================================================
 **
diff --git a/syscall/devices/hostfs/hostfs.c b/syscall/devices/hostfs/hostfs.c
index 66a94d7f6..5f40182c1 100644
--- a/syscall/devices/hostfs/hostfs.c
+++ b/syscall/devices/hostfs/hostfs.c
@@ -426,15 +426,14 @@ static oe_fd_t* _hostfs_open(
     int flags,
     oe_mode_t mode)
 {
-    if ((flags & OE_O_DIRECTORY))
-    {
-        /* Only existing directories can be opened, so mode is ignored. */
-        return _hostfs_open_directory(fs, pathname, flags);
-    }
-    else
-    {
-        return _hostfs_open_file(fs, pathname, flags, mode);
-    }
+    // EDG: It is valid to open a directory without O_DIRECTORY flag, so we
+    // cannot know if pathname is a directory or a file. Try to open pathname as
+    // a directory first.
+    oe_fd_t* result =
+        _hostfs_open_directory(fs, pathname, flags | OE_O_DIRECTORY);
+    if (!result && !(flags & OE_O_DIRECTORY))
+        result = _hostfs_open_file(fs, pathname, flags, mode);
+    return result;
 }
 
 static int _hostfs_flock(oe_fd_t* desc, int operation)
@@ -461,6 +460,10 @@ static int _hostfs_fsync(oe_fd_t* desc)
     if (!file)
         OE_RAISE_ERRNO(OE_EINVAL);
 
+    if (file->dir)
+        // EDG: fsync on directory not supported yet, ignore and return success
+        return 0;
+
     if (oe_syscall_fsync_ocall(&ret, file->host_fd) != OE_OK)
         OE_RAISE_ERRNO(OE_EINVAL);
 
@@ -1438,6 +1441,10 @@ static oe_host_fd_t _hostfs_get_host_fd(oe_fd_t* desc)
 {
     file_t* file = _cast_file(desc);
 
+    // EDG: set errno if this is a directory file
+    if (file && file->host_fd == -1)
+        oe_errno = OE_EINVAL;
+
     return file ? file->host_fd : -1;
 }
 
diff --git a/syscall/devices/hostsock/hostsock.c b/syscall/devices/hostsock/hostsock.c
index 9f2a6f51e..ef6be069e 100644
--- a/syscall/devices/hostsock/hostsock.c
+++ b/syscall/devices/hostsock/hostsock.c
@@ -20,6 +20,7 @@
 #include <openenclave/corelibc/stdlib.h>
 #include <openenclave/internal/raise.h>
 #include <openenclave/internal/safecrt.h>
+#include <openenclave/internal/ert/sock.h>
 #include "syscall_t.h"
 
 #define DEVICE_MAGIC 0x536f636b
@@ -34,13 +35,6 @@ typedef struct _device
     oe_host_fd_t host_fd;
 } device_t;
 
-typedef struct _sock
-{
-    oe_fd_t base;
-    uint32_t magic;
-    oe_host_fd_t host_fd;
-} sock_t;
-
 static sock_t* _new_sock(void)
 {
     sock_t* sock = NULL;
@@ -56,6 +50,11 @@ static sock_t* _new_sock(void)
     return sock;
 }
 
+sock_t* oe_hostsock_new_sock(void)
+{
+    return _new_sock();
+}
+
 static device_t* _cast_device(const oe_device_t* device)
 {
     device_t* p = (device_t*)device;
@@ -100,6 +99,8 @@ static oe_fd_t* _hostsock_device_socket(
     if (!(new_sock = _new_sock()))
         OE_RAISE_ERRNO(OE_ENOMEM);
 
+    // TODO Do not create host socket here, but in bind or connect.
+
     /* Call the host. */
     {
         oe_host_fd_t retval = -1;
@@ -114,6 +115,11 @@ static oe_fd_t* _hostsock_device_socket(
     }
 
     ret = &new_sock->base;
+
+    // EDG: remember flag for internal socket
+    if (type & SOCK_NONBLOCK)
+        new_sock->internal.flags = OE_O_NONBLOCK;
+
     new_sock = NULL;
 
 done:
@@ -210,6 +216,13 @@ static int _hostsock_connect(
     if (oe_memcpy_s(&buf, sizeof(buf), addr, addrlen) != OE_OK)
         OE_RAISE_ERRNO(OE_EINVAL);
 
+    // EDG: try internal first
+    const oe_result_t internal = oe_internalsock_connect(sock, addr);
+    if (internal == OE_OK)
+        return 0;
+    if (internal != OE_NOT_FOUND)
+        OE_RAISE_ERRNO(oe_errno);
+
     /* Call host. */
     if (oe_syscall_connect_ocall(&ret, sock->host_fd, &buf.addr, addrlen) !=
         OE_OK)
@@ -312,6 +325,13 @@ static int _hostsock_bind(
     if (oe_memcpy_s(&buf, sizeof(buf), addr, addrlen) != OE_OK)
         OE_RAISE_ERRNO(OE_EINVAL);
 
+    // EDG: try internal first
+    const oe_result_t internal = oe_internalsock_bind(sock, addr);
+    if (internal == OE_OK)
+        return 0;
+    if (internal != OE_NOT_FOUND)
+        OE_RAISE_ERRNO(oe_errno);
+
     /* Call the host. */
     if (oe_syscall_bind_ocall(&ret, sock->host_fd, &buf.addr, addrlen) != OE_OK)
         OE_RAISE_ERRNO(OE_EINVAL);
diff --git a/syscall/mount.c b/syscall/mount.c
index 6de079f60..07e1e1c32 100644
--- a/syscall/mount.c
+++ b/syscall/mount.c
@@ -160,6 +160,9 @@ int oe_mount(
     if (!device)
         OE_RAISE_ERRNO_MSG(OE_ENODEV, "filesystemtype=%s", filesystemtype);
 
+// EDG: disabled because we want to be able to mount anywhere without simulating
+// a complete root fs.
+#if 0
     /* Be sure the full_target directory exists (if not root). */
     if (oe_strcmp(target, "/") != 0)
     {
@@ -177,6 +180,7 @@ int oe_mount(
         if (!OE_S_ISDIR(buf.st_mode))
             OE_RAISE_ERRNO(OE_ENOTDIR);
     }
+#endif
 
     /* Lock the mount table. */
     oe_spin_lock(&_lock);
diff --git a/syscall/netdb.c b/syscall/netdb.c
index 26d943fdb..2edcb473a 100644
--- a/syscall/netdb.c
+++ b/syscall/netdb.c
@@ -2,6 +2,8 @@
 // Licensed under the MIT License.
 
 #include <openenclave/corelibc/stdlib.h>
+#include <openenclave/corelibc/string.h>
+#include <openenclave/internal/syscall/arpa/inet.h>
 #include <openenclave/internal/syscall/netdb.h>
 #include <openenclave/internal/syscall/raise.h>
 #include <openenclave/internal/syscall/resolver.h>
@@ -57,6 +59,360 @@ done:
     return ret;
 }
 
+#define OE_IN6_IS_ADDR_MULTICAST(a) (((uint8_t*)(a))[0] == 0xff)
+#define OE_IN6_IS_ADDR_LINKLOCAL(a) \
+    ((((uint8_t*)(a))[0]) == 0xfe && (((uint8_t*)(a))[1] & 0xc0) == 0x80)
+#define OE_IN6_IS_ADDR_MC_LINKLOCAL(a) \
+    (OE_IN6_IS_ADDR_MULTICAST(a) && ((((uint8_t*)(a))[1] & 0xf) == 0x2))
+
+// copied from musl/network/lookup.h
+struct address
+{
+    int family;
+    unsigned scopeid;
+    uint8_t addr[16];
+    int sortkey;
+};
+struct service
+{
+    uint16_t port;
+    unsigned char proto, socktype;
+};
+
+// copied from musl/network/lookup_name.c
+static int name_from_null(
+    struct address buf[static 2],
+    const char* name,
+    int family,
+    int flags)
+{
+    int cnt = 0;
+    if (name)
+        return 0;
+    if (flags & OE_AI_PASSIVE)
+    {
+        if (family != OE_AF_INET6)
+            buf[cnt++] = (struct address){.family = OE_AF_INET};
+        if (family != OE_AF_INET)
+            buf[cnt++] = (struct address){.family = OE_AF_INET6};
+    }
+    else
+    {
+        if (family != OE_AF_INET6)
+            buf[cnt++] =
+                (struct address){.family = OE_AF_INET, .addr = {127, 0, 0, 1}};
+        if (family != OE_AF_INET)
+            buf[cnt++] =
+                (struct address){.family = OE_AF_INET6, .addr = {[15] = 1}};
+    }
+    return cnt;
+}
+
+// adapted from musl/network/lookup_name.c
+// - Do not try to look up name in /etc/hosts and fail with OE_EAI_FAIL if the
+// name cannot be resolved internally.
+// - Do not sort results because it would require host calls.
+static int _lookup_name(
+    struct address buf[static 2],
+    char canon[static 256],
+    const char* name,
+    int family,
+    int flags)
+{
+    size_t strnlen(const char*, size_t);
+    int __lookup_ipliteral(
+        struct address buf[static 1], const char* name, int family);
+
+    int cnt = 0, i, j;
+
+    *canon = 0;
+    if (name)
+    {
+        /* reject empty name and check len so it fits into temp bufs */
+        size_t l = strnlen(name, 255);
+        if (l - 1 >= 254)
+            return OE_EAI_NONAME;
+        memcpy(canon, name, l + 1);
+    }
+
+    /* Procedurally, a request for v6 addresses with the v4-mapped
+     * flag set is like a request for unspecified family, followed
+     * by filtering of the results. */
+    if (flags & OE_AI_V4MAPPED)
+    {
+        if (family == OE_AF_INET6)
+            family = OE_AF_UNSPEC;
+        else
+            flags -= OE_AI_V4MAPPED;
+    }
+
+    /* Try each backend until there's at least one result. */
+    cnt = name_from_null(buf, name, family, flags);
+    if (!cnt)
+        cnt = __lookup_ipliteral(buf, name, family);
+    if (!cnt && !(flags & OE_AI_NUMERICHOST))
+    {
+        if (oe_strcmp(name, "localhost") == 0)
+            cnt = name_from_null(buf, NULL, family, 0);
+        if (!cnt)
+            // EDG: cannot be resolved internally (do not try /etc/hosts)
+            return OE_EAI_FAIL;
+    }
+    if (cnt <= 0)
+        return cnt ? cnt : OE_EAI_NONAME;
+
+    /* Filter/transform results for v4-mapped lookup, if requested. */
+    if (flags & OE_AI_V4MAPPED)
+    {
+        if (!(flags & OE_AI_ALL))
+        {
+            /* If any v6 results exist, remove v4 results. */
+            for (i = 0; i < cnt && buf[i].family != OE_AF_INET6; i++)
+                ;
+            if (i < cnt)
+            {
+                for (j = 0; i < cnt; i++)
+                {
+                    if (buf[i].family == OE_AF_INET6)
+                        buf[j++] = buf[i];
+                }
+                cnt = i = j;
+            }
+        }
+        /* Translate any remaining v4 results to v6 */
+        for (i = 0; i < cnt; i++)
+        {
+            if (buf[i].family != OE_AF_INET)
+                continue;
+            memcpy(buf[i].addr + 12, buf[i].addr, 4);
+            memcpy(buf[i].addr, "\0\0\0\0\0\0\0\0\0\0\xff\xff", 12);
+            buf[i].family = OE_AF_INET6;
+        }
+    }
+
+    return cnt;
+}
+
+// adapted from musl/network/lookup_serv.c
+// - do not try to look up name in /etc/services
+static int _lookup_serv(
+    struct service buf[static 2],
+    const char* name,
+    int proto,
+    int socktype,
+    int flags)
+{
+    int cnt = 0;
+    char* z = "";
+    unsigned long port = 0;
+
+    switch (socktype)
+    {
+        case OE_SOCK_STREAM:
+            switch (proto)
+            {
+                case 0:
+                    proto = IPPROTO_TCP;
+                case IPPROTO_TCP:
+                    break;
+                default:
+                    return OE_EAI_SERVICE;
+            }
+            break;
+        case OE_SOCK_DGRAM:
+            switch (proto)
+            {
+                case 0:
+                    proto = IPPROTO_UDP;
+                case IPPROTO_UDP:
+                    break;
+                default:
+                    return OE_EAI_SERVICE;
+            }
+        case 0:
+            break;
+        default:
+            if (name)
+                return OE_EAI_SERVICE;
+            buf[0].port = 0;
+            buf[0].proto = (unsigned char)proto;
+            buf[0].socktype = (unsigned char)socktype;
+            return 1;
+    }
+
+    if (name)
+    {
+        if (!*name)
+            return OE_EAI_SERVICE;
+        port = oe_strtoul(name, &z, 10);
+    }
+    if (!*z)
+    {
+        if (port > 65535)
+            return OE_EAI_SERVICE;
+        if (proto != IPPROTO_UDP)
+        {
+            buf[cnt].port = (uint16_t)port;
+            buf[cnt].socktype = OE_SOCK_STREAM;
+            buf[cnt++].proto = IPPROTO_TCP;
+        }
+        if (proto != IPPROTO_TCP)
+        {
+            buf[cnt].port = (uint16_t)port;
+            buf[cnt].socktype = OE_SOCK_DGRAM;
+            buf[cnt++].proto = IPPROTO_UDP;
+        }
+        return cnt;
+    }
+
+    if (flags & OE_AI_NUMERICSERV)
+        return OE_EAI_NONAME;
+
+    return OE_EAI_SERVICE;
+}
+
+// adapted from musl/network/getaddrinfo.c
+// This function fails with OE_EAI_FAIL if the name cannot be resolved
+// internally, i.e., is not an IP address. In this case the request may be
+// forwarded to the host. On other errors the request must not be forwarded to
+// the host. Consider these examples:
+// 255.0.0.1:80 succeeds.
+// myhost:80 fails with OE_EAI_FAIL and may be resolved by the host.
+// myhost:http fails with OE_EAI_FAIL and may be resolved by the host.
+// 255.0.0.1:http fails with OE_EAI_SERVICE and must not be resolved by the host
+// because it could return another IP address. We could add additional logic if
+// we ever need to resolve this combination of host/service.
+static int _getaddrinfo(
+    const char* restrict host,
+    const char* restrict serv,
+    const struct oe_addrinfo* restrict hint,
+    struct oe_addrinfo** restrict res)
+{
+    struct service ports[2];
+    struct address addrs[2];
+    char canon[256];
+    int nservs, naddrs, i, j;
+    int family = OE_AF_UNSPEC, flags = 0, proto = 0, socktype = 0;
+
+    if (!host && !serv)
+        return OE_EAI_NONAME;
+
+    if (hint)
+    {
+        family = hint->ai_family;
+        flags = hint->ai_flags;
+        proto = hint->ai_protocol;
+        socktype = hint->ai_socktype;
+
+        const int mask = OE_AI_PASSIVE | OE_AI_CANONNAME | OE_AI_NUMERICHOST |
+                         OE_AI_V4MAPPED | OE_AI_ALL | OE_AI_ADDRCONFIG |
+                         OE_AI_NUMERICSERV;
+        if ((flags & mask) != flags)
+            return OE_EAI_BADFLAGS;
+
+        switch (family)
+        {
+            case OE_AF_INET:
+            case OE_AF_INET6:
+            case OE_AF_UNSPEC:
+                break;
+            default:
+                return OE_EAI_FAMILY;
+        }
+    }
+
+    // EDG: Ignore AI_ADDRCONFIG flag because it would require to create a host
+    // socket.
+
+    // EDG: Look up name first so that something like myhost:http fails with
+    // OE_EAI_FAIL instead of OE_EAI_SERVICE and, thus, will be forwarded to the
+    // host.
+    naddrs = _lookup_name(addrs, canon, host, family, flags);
+    if (naddrs < 0)
+        return naddrs;
+
+    nservs = _lookup_serv(ports, serv, proto, socktype, flags);
+    if (nservs < 0)
+        return nservs;
+
+    // EDG: Memory allocation for the result differs from the musl
+    // implementation such that it is compatible with the oe_freeaddrinfo
+    // implementation.
+
+    const size_t canon_len = oe_strlen(canon);
+
+    struct oe_addrinfo* head = NULL;
+    struct oe_addrinfo** next = &head;
+
+    for (i = 0; i < naddrs; i++)
+        for (j = 0; j < nservs; j++)
+        {
+            struct oe_addrinfo* const ai = oe_malloc(sizeof *ai);
+            if (!ai)
+            {
+                oe_freeaddrinfo(head);
+                return OE_EAI_MEMORY;
+            }
+            *next = ai;
+            next = &ai->ai_next;
+
+            *ai = (struct oe_addrinfo){
+                .ai_family = addrs[i].family,
+                .ai_socktype = ports[j].socktype,
+                .ai_protocol = ports[j].proto,
+                .ai_addrlen = addrs[i].family == OE_AF_INET
+                                  ? sizeof(struct oe_sockaddr_in)
+                                  : sizeof(struct oe_sockaddr_in6),
+                .ai_addr = NULL,
+                .ai_canonname = NULL,
+                .ai_next = NULL};
+
+            ai->ai_addr = oe_calloc(1, ai->ai_addrlen);
+            if (!ai->ai_addr)
+            {
+                oe_freeaddrinfo(head);
+                return OE_EAI_MEMORY;
+            }
+
+            switch (addrs[i].family)
+            {
+                case OE_AF_INET:
+                {
+                    struct oe_sockaddr_in* const sin =
+                        (struct oe_sockaddr_in*)ai->ai_addr;
+                    sin->sin_family = OE_AF_INET;
+                    sin->sin_port = oe_htons(ports[j].port);
+                    memcpy(&sin->sin_addr, &addrs[i].addr, 4);
+                }
+                break;
+                case OE_AF_INET6:
+                {
+                    struct oe_sockaddr_in6* const sin6 =
+                        (struct oe_sockaddr_in6*)ai->ai_addr;
+                    sin6->sin6_family = OE_AF_INET6;
+                    sin6->sin6_port = oe_htons(ports[j].port);
+                    sin6->sin6_scope_id = addrs[i].scopeid;
+                    memcpy(&sin6->sin6_addr, &addrs[i].addr, 16);
+                }
+                break;
+            }
+
+            if (canon_len)
+            {
+                char* const cn = oe_malloc(canon_len + 1);
+                if (!cn)
+                {
+                    oe_freeaddrinfo(head);
+                    return OE_EAI_MEMORY;
+                }
+                memcpy(cn, canon, canon_len + 1);
+                ai->ai_canonname = cn;
+            }
+        }
+    *res = head;
+    return 0;
+}
+
 int oe_getaddrinfo(
     const char* node,
     const char* service,
@@ -72,6 +428,12 @@ int oe_getaddrinfo(
     else
         OE_RAISE_ERRNO(OE_EINVAL);
 
+    // EDG: Try to resolve internally. This is important for internal sockets
+    // because the host could otherwise hijack them.
+    const int ret_getaddrinfo = _getaddrinfo(node, service, hints, res_out);
+    if (ret_getaddrinfo != OE_EAI_FAIL)
+        return ret_getaddrinfo;
+
     oe_spin_lock(&_lock);
     locked = true;
 
@@ -94,6 +456,131 @@ done:
     return ret;
 }
 
+// copied from musl/src/getnameinfo.c
+static char* itoa(char* p, unsigned x)
+{
+    p += 3 * sizeof(int);
+    *--p = 0;
+    do
+    {
+        *--p = (char)('0' + x % 10);
+        x /= 10;
+    } while (x);
+    return p;
+}
+
+// copied from musl/src/getnameinfo.c
+static void mkptr4(char* s, const unsigned char* ip)
+{
+    int sprintf();
+    sprintf(s, "%d.%d.%d.%d.in-addr.arpa", ip[3], ip[2], ip[1], ip[0]);
+}
+
+// copied from musl/src/getnameinfo.c
+static void mkptr6(char* s, const unsigned char* ip)
+{
+    static const char xdigits[] = "0123456789abcdef";
+    int i;
+    for (i = 15; i >= 0; i--)
+    {
+        *s++ = xdigits[ip[i] & 15];
+        *s++ = '.';
+        *s++ = xdigits[ip[i] >> 4];
+        *s++ = '.';
+    }
+    char* strcpy(char*, const char*);
+    strcpy(s, "ip6.arpa");
+}
+
+#define IF_NAMESIZE 16
+
+// adapted from musl/src/getnameinfo.c
+// do not try hosts/services file or DNS
+static int _getnameinfo(
+    const struct oe_sockaddr* restrict sa,
+    oe_socklen_t sl,
+    char* restrict node,
+    oe_socklen_t nodelen,
+    char* restrict serv,
+    oe_socklen_t servlen,
+    int flags)
+{
+    char* strcpy(char*, const char*);
+    char* strcat(char*, const char*);
+    const char* inet_ntop(int, const void*, char*, oe_socklen_t);
+    char* if_indextoname(unsigned int, char*);
+
+    const size_t PTR_MAX = 64 + sizeof ".in-addr.arpa";
+
+    char ptr[PTR_MAX];
+    char buf[256], num[3 * sizeof(int) + 1];
+    int af = sa->sa_family;
+    unsigned char* a;
+    unsigned scopeid;
+
+    switch (af)
+    {
+        case OE_AF_INET:
+            a = (void*)&((struct oe_sockaddr_in*)sa)->sin_addr;
+            if (sl < sizeof(struct oe_sockaddr_in))
+                return OE_EAI_FAMILY;
+            mkptr4(ptr, a);
+            scopeid = 0;
+            break;
+        case OE_AF_INET6:
+            a = (void*)&((struct oe_sockaddr_in6*)sa)->sin6_addr;
+            if (sl < sizeof(struct oe_sockaddr_in6))
+                return OE_EAI_FAMILY;
+            if (memcmp(a, "\0\0\0\0\0\0\0\0\0\0\xff\xff", 12))
+                mkptr6(ptr, a);
+            else
+                mkptr4(ptr, a + 12);
+            scopeid = ((struct oe_sockaddr_in6*)sa)->sin6_scope_id;
+            break;
+        default:
+            return OE_EAI_FAMILY;
+    }
+
+    if (node && nodelen)
+    {
+        buf[0] = 0;
+        {
+            if (flags & OE_NI_NAMEREQD)
+                return OE_EAI_NONAME;
+            inet_ntop(af, a, buf, sizeof buf);
+            if (scopeid)
+            {
+                char *p = 0, tmp[IF_NAMESIZE + 1];
+                if (!(flags & OE_NI_NUMERICSCOPE) &&
+                    (OE_IN6_IS_ADDR_LINKLOCAL(a) ||
+                     OE_IN6_IS_ADDR_MC_LINKLOCAL(a)))
+                    p = if_indextoname(scopeid, tmp + 1);
+                if (!p)
+                    p = itoa(num, scopeid);
+                *--p = '%';
+                strcat(buf, p);
+            }
+        }
+        if (oe_strlen(buf) >= nodelen)
+            return OE_EAI_OVERFLOW;
+        strcpy(node, buf);
+    }
+
+    if (serv && servlen)
+    {
+        char* p = buf;
+        int port = oe_ntohs(((struct oe_sockaddr_in*)sa)->sin_port);
+        buf[0] = 0;
+        if (!*p)
+            p = itoa(num, (unsigned)port);
+        if (oe_strlen(p) >= servlen)
+            return OE_EAI_OVERFLOW;
+        strcpy(serv, p);
+    }
+
+    return 0;
+}
+
 int oe_getnameinfo(
     const struct oe_sockaddr* sa,
     oe_socklen_t salen,
@@ -106,6 +593,12 @@ int oe_getnameinfo(
     ssize_t ret = OE_EAI_FAIL;
     bool locked = false;
 
+    // EDG: Try to resolve internally.
+    const int ret_getnameinfo =
+        _getnameinfo(sa, salen, host, hostlen, serv, servlen, flags);
+    if (ret_getnameinfo != OE_EAI_NONAME)
+        return ret_getnameinfo;
+
     oe_spin_lock(&_lock);
     locked = true;
 
diff --git a/syscall/poll.c b/syscall/poll.c
index 072e4fec5..a70034931 100644
--- a/syscall/poll.c
+++ b/syscall/poll.c
@@ -16,7 +16,9 @@ int oe_poll(struct oe_pollfd* fds, oe_nfds_t nfds, int timeout)
     struct oe_host_pollfd* host_fds = NULL;
     oe_nfds_t i;
 
-    if (!fds || nfds == 0)
+    // EDG: poll with nfds=0 can be used as sleep. (Python uses it this way and
+    // it is also documented in the manpage.)
+    if (!fds) // || nfds == 0)
         OE_RAISE_ERRNO(OE_EINVAL);
 
     if (!(host_fds = oe_calloc(nfds, sizeof(struct oe_host_pollfd))))
diff --git a/syscall/syscall.c b/syscall/syscall.c
index e81bcfa61..de2479d39 100644
--- a/syscall/syscall.c
+++ b/syscall/syscall.c
@@ -198,6 +198,15 @@ OE_WEAK OE_DEFINE_SYSCALL4_M(SYS_epoll_wait)
 }
 #endif
 
+OE_WEAK OE_DEFINE_SYSCALL2(SYS_eventfd2)
+{
+    oe_errno = 0;
+    const unsigned int initval = (unsigned int)arg1;
+    const int flags = (int)arg2;
+    int oe_eventfd(unsigned int initval, int flags);
+    return oe_eventfd(initval, flags);
+}
+
 OE_WEAK OE_DEFINE_SYSCALL1(SYS_exit)
 {
     oe_errno = 0;
@@ -1107,6 +1116,7 @@ static long _syscall(
 #if __x86_64__ || _M_X64
         OE_SYSCALL_DISPATCH(SYS_epoll_wait, arg1, arg2, arg3, arg4);
 #endif
+        OE_SYSCALL_DISPATCH(SYS_eventfd2, arg1, arg2);
         OE_SYSCALL_DISPATCH(SYS_exit, arg1);
         OE_SYSCALL_DISPATCH(SYS_exit_group, arg1);
         OE_SYSCALL_DISPATCH(SYS_faccessat, arg1, arg2, arg3, arg4);
diff --git a/syscall/unistd.c b/syscall/unistd.c
index 943528b51..11ef0abc5 100644
--- a/syscall/unistd.c
+++ b/syscall/unistd.c
@@ -288,6 +288,23 @@ done:
     return ret;
 }
 
+int oe_close_hostfd(oe_host_fd_t fd)
+{
+    int ret = -1;
+    int retval = -1;
+
+    if (oe_syscall_close_ocall(&retval, fd) != OE_OK)
+        OE_RAISE_ERRNO(OE_EINVAL);
+
+    if (retval == -1)
+        OE_RAISE_ERRNO(oe_errno);
+
+    ret = retval;
+
+done:
+    return ret;
+}
+
 int oe_flock(int fd, int operation)
 {
     int ret = -1;
diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt
index 8d188a458..c886a1ecc 100644
--- a/tests/CMakeLists.txt
+++ b/tests/CMakeLists.txt
@@ -95,7 +95,7 @@ if (UNIX
     add_subdirectory(custom_claims)
     add_subdirectory(debug-mode)
     add_subdirectory(ecall)
-    add_subdirectory(ecall_conflict)
+    #add_subdirectory(ecall_conflict)
     add_subdirectory(ecall_ocall)
     add_subdirectory(echo)
     add_subdirectory(enclaveparam)
@@ -166,7 +166,7 @@ if (UNIX)
     # process does. At this point, the host fs that libgcov requires can no
     # longer be used.
     if (NOT CODE_COVERAGE)
-      add_subdirectory(child_process)
+      #add_subdirectory(child_process)
     endif ()
   endif ()
   add_subdirectory(libc)
diff --git a/tests/crypto/enclave/enc/enc.c b/tests/crypto/enclave/enc/enc.c
index cfbd81120..862f0d4ea 100644
--- a/tests/crypto/enclave/enc/enc.c
+++ b/tests/crypto/enclave/enc/enc.c
@@ -168,7 +168,7 @@ static long _syscall_dispatch(
         OE_SYSCALL_DISPATCH(SYS_readv, arg1, arg2, arg3);
         OE_SYSCALL_DISPATCH(SYS_close, arg1);
         default:
-            return -1;
+            return -2;
     }
 }
 
@@ -190,7 +190,8 @@ static oe_result_t _syscall_hook(
         OE_RAISE(OE_INVALID_PARAMETER);
 
     *ret = _syscall_dispatch(number, arg1, arg2, arg3, arg4, arg5, arg6);
-    result = OE_OK;
+    if (*ret != -2)
+        result = OE_OK;
 done:
     return result;
 }
diff --git a/tests/mbed/enc/enc.c b/tests/mbed/enc/enc.c
index 2c82b6c72..2ddd2619a 100644
--- a/tests/mbed/enc/enc.c
+++ b/tests/mbed/enc/enc.c
@@ -130,6 +130,7 @@ OE_DEFINE_SYSCALL3_M(SYS_writev)
     // expecting the runtime implementation of SYS_writev to also be
     // called.
     tls_result = OE_UNSUPPORTED;
+    errno = 1; // EDG: we don't accept a return value of -1 with errno=0
     return ret;
 }
 
diff --git a/tests/sealKey/host/host.cpp b/tests/sealKey/host/host.cpp
index 10286da24..db9188cf7 100644
--- a/tests/sealKey/host/host.cpp
+++ b/tests/sealKey/host/host.cpp
@@ -156,11 +156,6 @@ int main(int argc, const char* argv[])
     }
 
     const uint32_t flags = oe_get_create_flags();
-    if ((flags & OE_ENCLAVE_FLAG_SIMULATE) != 0)
-    {
-        printf("=== Skipped unsupported test in simulation mode (sealKey)\n");
-        return SKIP_RETURN_CODE;
-    }
 
     printf("=== This program is used to test enclave seal key functions.\n");
 
diff --git a/tests/syscall/poller/client.cpp b/tests/syscall/poller/client.cpp
index c09560c7f..927be2ded 100644
--- a/tests/syscall/poller/client.cpp
+++ b/tests/syscall/poller/client.cpp
@@ -17,7 +17,7 @@
 
 extern "C" void oe_abort();
 
-void run_client(uint16_t port)
+void run_client(uint32_t ipaddr, uint16_t port)
 {
     socket_t sd;
     const char alphabet[] = "abcdefghijklmnopqrstuvwxyz";
@@ -37,7 +37,7 @@ void run_client(uint16_t port)
         struct sockaddr_in addr;
         memset(&addr, 0, sizeof(addr));
         addr.sin_family = AF_INET;
-        addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
+        addr.sin_addr.s_addr = htonl(ipaddr);
         addr.sin_port = htons(port);
 
         if (connect(sd, (struct sockaddr*)&addr, sizeof(addr)) != 0)
diff --git a/tests/syscall/poller/client.h b/tests/syscall/poller/client.h
index 060657741..a57d92704 100644
--- a/tests/syscall/poller/client.h
+++ b/tests/syscall/poller/client.h
@@ -6,6 +6,6 @@
 
 #include <stdint.h>
 
-void run_client(uint16_t port);
+void run_client(uint32_t ipaddr, uint16_t port);
 
 #endif /* _OE_TESTS_LIBCSOCKETS_CLIENT_H */
diff --git a/tests/syscall/poller/enc/enc.cpp b/tests/syscall/poller/enc/enc.cpp
index a8ee8b96f..b8bcd22c6 100644
--- a/tests/syscall/poller/enc/enc.cpp
+++ b/tests/syscall/poller/enc/enc.cpp
@@ -22,18 +22,19 @@ static void _init(void)
 }
 
 extern "C" void run_enclave_server(
+    uint32_t ipaddr,
     uint16_t port,
     size_t num_clients,
     uint32_t poller_type)
 {
     _init();
-    run_server(port, num_clients, poller_type_t(poller_type));
+    run_server(ipaddr, port, num_clients, poller_type_t(poller_type));
 }
 
-extern "C" void run_enclave_client(uint16_t port)
+extern "C" void run_enclave_client(uint32_t ipaddr, uint16_t port)
 {
     _init();
-    run_client(port);
+    run_client(ipaddr, port);
 }
 
 extern "C" void test_fd_set(void)
diff --git a/tests/syscall/poller/host/host.cpp b/tests/syscall/poller/host/host.cpp
index 1c4cd0833..a107308ca 100644
--- a/tests/syscall/poller/host/host.cpp
+++ b/tests/syscall/poller/host/host.cpp
@@ -22,12 +22,13 @@ static oe_enclave_t* _enclave;
 typedef struct thread_arg
 {
     poller_type_t poller_type;
+    uint32_t ipaddr;
 } server_arg_t;
 
 static void* _run_host_client(void* arg)
 {
     OE_UNUSED(arg);
-    run_client(PORT);
+    run_client(static_cast<thread_arg*>(arg)->ipaddr, PORT);
     return NULL;
 }
 
@@ -35,7 +36,7 @@ static void* _run_host_server(void* arg_)
 {
     server_arg_t* arg = (server_arg_t*)arg_;
 
-    run_server(PORT, NUM_CLIENTS, arg->poller_type);
+    run_server(arg->ipaddr, PORT, NUM_CLIENTS, arg->poller_type);
 
     return NULL;
 }
@@ -44,7 +45,8 @@ static void* _run_enclave_server(void* arg_)
 {
     server_arg_t* arg = (server_arg_t*)arg_;
 
-    run_enclave_server(_enclave, PORT, NUM_CLIENTS, arg->poller_type);
+    run_enclave_server(
+        _enclave, arg->ipaddr, PORT, NUM_CLIENTS, arg->poller_type);
 
     return NULL;
 }
@@ -53,7 +55,7 @@ static void* _run_enclave_client(void* arg)
 {
     OE_UNUSED(arg);
 
-    run_enclave_client(_enclave, PORT);
+    run_enclave_client(_enclave, static_cast<thread_arg*>(arg)->ipaddr, PORT);
 
     return NULL;
 }
@@ -61,11 +63,12 @@ static void* _run_enclave_client(void* arg)
 void run_test(
     void* (*client_proc)(void*),
     void* (*server_proc)(void*),
-    poller_type_t poller_type)
+    poller_type_t poller_type,
+    uint32_t ipaddr = INADDR_LOOPBACK)
 {
     thread_t clients[NUM_CLIENTS];
     thread_t server;
-    server_arg_t arg = {poller_type};
+    thread_arg arg = {poller_type, ipaddr};
 
     if (thread_create(&server, server_proc, &arg) != 0)
     {
@@ -76,7 +79,7 @@ void run_test(
 
     for (size_t i = 0; i < NUM_CLIENTS; i++)
     {
-        if (thread_create(&clients[i], client_proc, NULL) != 0)
+        if (thread_create(&clients[i], client_proc, &arg) != 0)
         {
             OE_TEST("thread_create()" == NULL);
         }
@@ -120,6 +123,14 @@ void test_enclave_to_enclave(poller_type_t poller_type)
     fflush(stdout);
 }
 
+static void test_enclave_to_enclave_internal(poller_type_t poller_type)
+{
+    printf("=== start %s(): %s\n", __FUNCTION__, poller::name(poller_type));
+    run_test(_run_enclave_client, _run_enclave_server, poller_type, 0xFF000001);
+    printf("=== passed %s(): %s\n", __FUNCTION__, poller::name(poller_type));
+    fflush(stdout);
+}
+
 int main(int argc, const char* argv[])
 {
     oe_result_t r;
@@ -154,6 +165,7 @@ int main(int argc, const char* argv[])
     test_enclave_to_host(poller_type);
     test_host_to_enclave(poller_type);
     test_enclave_to_enclave(poller_type);
+    test_enclave_to_enclave_internal(poller_type);
 
     test_fd_set(_enclave);
 
diff --git a/tests/syscall/poller/poller.edl b/tests/syscall/poller/poller.edl
index 419c4d27a..52858f4b5 100644
--- a/tests/syscall/poller/poller.edl
+++ b/tests/syscall/poller/poller.edl
@@ -12,15 +12,18 @@ enclave {
 #else
     from "openenclave/edl/optee/platform.edl" import *;
 #endif
+    from "openenclave/edl/syscall.edl" import oe_syscall_eventfd_ocall;
 
     trusted {
 
         public void run_enclave_server(
+            uint32_t ipaddr,
             uint16_t port,
             size_t num_clients,
             uint32_t poller_type);
 
         public void run_enclave_client(
+            uint32_t ipaddr,
             uint16_t port);
 
         public void test_fd_set();
diff --git a/tests/syscall/poller/server.cpp b/tests/syscall/poller/server.cpp
index 8e656ab3e..e1305920c 100644
--- a/tests/syscall/poller/server.cpp
+++ b/tests/syscall/poller/server.cpp
@@ -19,7 +19,7 @@
 
 extern "C" void oe_abort();
 
-socket_t create_listener_socket(uint16_t port)
+socket_t create_listener_socket(uint32_t ipaddr, uint16_t port)
 {
     socket_t ret = INVALID_SOCKET;
     socket_t sock = INVALID_SOCKET;
@@ -36,7 +36,7 @@ socket_t create_listener_socket(uint16_t port)
 
     memset(&addr, 0, sizeof(addr));
     addr.sin_family = AF_INET;
-    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
+    addr.sin_addr.s_addr = htonl(ipaddr);
     addr.sin_port = htons(port);
 
     if (bind(sock, (struct sockaddr*)&addr, sizeof(addr)) != 0)
@@ -75,6 +75,7 @@ client_t* find_client(std::vector<client_t>& clients, socket_t sock)
 }
 
 extern "C" void run_server(
+    uint32_t ipaddr,
     uint16_t port,
     size_t num_clients,
     poller_type_t poller_type)
@@ -89,7 +90,7 @@ extern "C" void run_server(
 
     sock_startup();
 
-    if ((listener = create_listener_socket(port)) == INVALID_SOCKET)
+    if ((listener = create_listener_socket(ipaddr, port)) == INVALID_SOCKET)
     {
         OE_TEST("create_listener_socket() failed" == NULL);
     }
diff --git a/tests/syscall/poller/server.h b/tests/syscall/poller/server.h
index 786180db6..d8582b1de 100644
--- a/tests/syscall/poller/server.h
+++ b/tests/syscall/poller/server.h
@@ -8,6 +8,7 @@
 #include "poller.h"
 
 extern "C" void run_server(
+    uint32_t ipaddr,
     uint16_t port,
     size_t num_clients,
     poller_type_t poller_type);
diff --git a/tests/syscall/resolver/enc/enc.c b/tests/syscall/resolver/enc/enc.c
index 032861859..62ffb759c 100644
--- a/tests/syscall/resolver/enc/enc.c
+++ b/tests/syscall/resolver/enc/enc.c
@@ -18,9 +18,12 @@ size_t oe_debug_malloc_check();
 
 struct addrinfo;
 
+static bool _initialized;
+
 int ecall_device_init()
 {
     OE_TEST(oe_load_module_host_resolver() == OE_OK);
+    _initialized = true;
     return 0;
 }
 
@@ -51,11 +54,35 @@ int ecall_getnameinfo(char* buffer, size_t bufflen)
         0);
 
     OE_TEST(rslt == 0);
-    OE_TEST(strcmp(host, "") != 0);
-    OE_TEST(strcmp(serv, "") != 0);
+    OE_TEST(strcmp(host, "127.0.0.1") == 0);
+    OE_TEST(strcmp(serv, "23") == 0);
 
     strlcpy(buffer, host, bufflen);
 
+    *host = 0;
+    *serv = 0;
+
+    // test with NI_NAMEREQD
+    rslt = oe_getnameinfo(
+        (const struct oe_sockaddr*)&addr,
+        sizeof(addr),
+        host,
+        sizeof(host),
+        serv,
+        sizeof(serv),
+        OE_NI_NAMEREQD);
+
+    if (_initialized)
+    {
+        // expect that it can be resolved by the host
+        OE_TEST(rslt == 0);
+        OE_TEST(*host);
+        OE_TEST(*serv);
+    }
+    else
+        // with NI_NAMEREQD it cannot be resolved internally
+        OE_TEST(rslt == OE_EAI_SYSTEM);
+
     return 0;
 }
 
@@ -173,7 +200,8 @@ done:
 int ecall_getaddrinfo(struct oe_addrinfo** res)
 {
     struct oe_addrinfo* ai = NULL;
-    const char host[] = {"localhost"};
+    const char host[] = {
+        "lOcalhOst"}; // capital letters force external resolution
     const char serv[] = {"telnet"};
     struct oe_addrinfo hints;
 
@@ -194,6 +222,36 @@ int ecall_getaddrinfo(struct oe_addrinfo** res)
     return 0;
 }
 
+void ecall_getaddrinfo_internally(void)
+{
+    struct oe_addrinfo* ai = NULL;
+
+    OE_TEST(oe_getaddrinfo("2.3.4.5", "1111", NULL, &ai) == 0);
+    OE_TEST(ai && ai->ai_addr);
+    OE_TEST(ai->ai_addr->sa_family == AF_INET);
+    const struct oe_sockaddr_in* ad = (struct oe_sockaddr_in*)ai->ai_addr;
+    OE_TEST(ntohl(ad->sin_addr.s_addr) == 0x02030405);
+    OE_TEST(ntohs(ad->sin_port) == 1111);
+    oe_freeaddrinfo(ai);
+
+    // IP addresses should never be resolved by the host.
+    // Named services cannot be resolved internally so the following fails.
+    // (We may implement internal service name resolution if we ever need it.)
+    ai = NULL;
+    OE_TEST(oe_getaddrinfo("2.3.4.5", "telnet", NULL, &ai) == OE_EAI_SERVICE);
+    OE_TEST(!ai);
+
+    // localhost can be resolved internally
+    ai = NULL;
+    OE_TEST(oe_getaddrinfo("localhost", "1111", NULL, &ai) == 0);
+    OE_TEST(ai && ai->ai_addr);
+    OE_TEST(ai->ai_addr->sa_family == AF_INET);
+    ad = (struct oe_sockaddr_in*)ai->ai_addr;
+    OE_TEST(ntohl(ad->sin_addr.s_addr) == OE_INADDR_LOOPBACK);
+    OE_TEST(ntohs(ad->sin_port) == 1111);
+    oe_freeaddrinfo(ai);
+}
+
 OE_SET_ENCLAVE_SGX(
     1,    /* ProductID */
     1,    /* SecurityVersion */
diff --git a/tests/syscall/resolver/host/host.c b/tests/syscall/resolver/host/host.c
index e331b4372..5ab91f2a8 100644
--- a/tests/syscall/resolver/host/host.c
+++ b/tests/syscall/resolver/host/host.c
@@ -66,6 +66,11 @@ int main(int argc, const char* argv[])
 
     OE_TEST(result == OE_OK);
 
+    // test without host resolver loaded
+    OE_TEST(ecall_getaddrinfo_internally(client_enclave) == OE_OK);
+    OE_TEST(
+        ecall_getnameinfo(client_enclave, &ret, host, sizeof(host)) == OE_OK);
+
     OE_TEST(ecall_device_init(client_enclave, &ret) == OE_OK);
 
     OE_TEST(ecall_getaddrinfo(client_enclave, &ret, &addrinfo) == OE_OK);
@@ -124,6 +129,9 @@ int main(int argc, const char* argv[])
         printf("host received: host = %s\n", host);
     }
 
+    // test with host resolver loaded
+    OE_TEST(ecall_getaddrinfo_internally(client_enclave) == OE_OK);
+
     OE_TEST(oe_terminate_enclave(client_enclave) == OE_OK);
 
     printf("=== passed all tests (resolver_test)\n");
diff --git a/tests/syscall/resolver/resolver_test.edl b/tests/syscall/resolver/resolver_test.edl
index 71cc46369..5cd14e2b4 100644
--- a/tests/syscall/resolver/resolver_test.edl
+++ b/tests/syscall/resolver/resolver_test.edl
@@ -18,6 +18,8 @@ enclave {
         public int ecall_getaddrinfo(
             [in,out,count=1] struct oe_addrinfo** res);
 
+        public void ecall_getaddrinfo_internally();
+
         public int ecall_getnameinfo(
             [in, out, count=bufflen] char* buffer,
             size_t bufflen);
diff --git a/tests/syscall/socket/enc/enc.c b/tests/syscall/socket/enc/enc.c
index 73e81ccf0..e89e4f02a 100644
--- a/tests/syscall/socket/enc/enc.c
+++ b/tests/syscall/socket/enc/enc.c
@@ -39,7 +39,7 @@ static void _initialize()
 /* This client connects to an echo server, sends a text message,
  * and outputs the text reply.
  */
-int ecall_run_client(char* recv_buff, ssize_t* recv_buff_len)
+int ecall_run_client(uint32_t ipaddr, char* recv_buff, ssize_t* recv_buff_len)
 {
     _initialize();
     int sockfd = 0;
@@ -55,7 +55,7 @@ int ecall_run_client(char* recv_buff, ssize_t* recv_buff_len)
         return OE_FAILURE;
     }
     serv_addr.sin_family = OE_AF_INET;
-    serv_addr.sin_addr.s_addr = oe_htonl(OE_INADDR_LOOPBACK);
+    serv_addr.sin_addr.s_addr = oe_htonl(ipaddr);
     serv_addr.sin_port = oe_htons(1492);
 
     printf("socket fd = %d\n", sockfd);
@@ -85,7 +85,8 @@ int ecall_run_client(char* recv_buff, ssize_t* recv_buff_len)
         oe_getpeername(
             sockfd, (struct oe_sockaddr*)&peer_addr, &peer_addr_len) == 0);
     OE_TEST(peer_addr_len == sizeof(serv_addr));
-    OE_TEST(memcmp(&serv_addr, &peer_addr, peer_addr_len) == 0);
+    // OE_TEST(memcmp(&serv_addr, &peer_addr, peer_addr_len) == 0);
+    OE_TEST(serv_addr.sin_addr.s_addr == peer_addr.sin_addr.s_addr);
 
     int sockdup = oe_dup(sockfd);
 
@@ -117,7 +118,7 @@ int ecall_run_client(char* recv_buff, ssize_t* recv_buff_len)
 /* This server acts as an echo server.  It accepts a connection,
  * receives messages, and echoes them back.
  */
-int ecall_run_server()
+int ecall_run_server(uint32_t ipaddr)
 {
     _initialize();
     int status = OE_FAILURE;
@@ -136,8 +137,8 @@ int ecall_run_server()
     }
 
     serv_addr.sin_family = OE_AF_INET;
-    serv_addr.sin_addr.s_addr = oe_htonl(OE_INADDR_LOOPBACK);
-    serv_addr.sin_port = oe_htons(1493);
+    serv_addr.sin_addr.s_addr = oe_htonl(ipaddr);
+    serv_addr.sin_port = oe_htons(1492);
 
     printf("enclave: binding\n");
     rtn = oe_bind(listenfd, (struct oe_sockaddr*)&serv_addr, sizeof(serv_addr));
@@ -172,7 +173,7 @@ int ecall_run_server()
         OE_TEST(peer_addr_len == sizeof(peer_addr));
         OE_TEST(peer_addr.sin_family == OE_AF_INET);
         OE_TEST(oe_ntohs(peer_addr.sin_port) >= 1024);
-        OE_TEST(oe_ntohl(peer_addr.sin_addr.s_addr) == OE_INADDR_LOOPBACK);
+        OE_TEST(oe_ntohl(peer_addr.sin_addr.s_addr) == ipaddr);
 
         if (connfd >= 0)
         {
@@ -225,4 +226,4 @@ OE_SET_ENCLAVE_SGX(
     true, /* Debug */
     256,  /* NumHeapPages */
     256,  /* NumStackPages */
-    1);   /* NumTCS */
+    2);   /* NumTCS */
diff --git a/tests/syscall/socket/host/host.c b/tests/syscall/socket/host/host.c
index 05180cb6c..4c4a52fb6 100644
--- a/tests/syscall/socket/host/host.c
+++ b/tests/syscall/socket/host/host.c
@@ -32,7 +32,7 @@ void* enclave_server_thread(void* arg)
     r = oe_create_socket_test_enclave(arg, type, flags, NULL, 0, &enclave);
     OE_TEST(r == OE_OK);
 
-    OE_TEST(ecall_run_server(enclave, &retval) == OE_OK);
+    OE_TEST(ecall_run_server(enclave, &retval, INADDR_LOOPBACK) == OE_OK);
 
     return NULL;
 }
@@ -181,7 +181,8 @@ static void _run_host_server_test(const char* path)
 
     test_data_len = 1024;
     OE_TEST(
-        ecall_run_client(enclave, &ret, test_data_rtn, &test_data_len) ==
+        ecall_run_client(
+            enclave, &ret, INADDR_LOOPBACK, test_data_rtn, &test_data_len) ==
         OE_OK);
 
     printf("host received: %.*s\n", (int)test_data_len, test_data_rtn);
@@ -197,7 +198,7 @@ static void _run_enclave_server_test(const char* path)
 {
     static char TESTDATA[] = "This is TEST DATA\n";
     thread_t thread;
-    const in_port_t PORT = 1493;
+    const in_port_t PORT = 1492;
 
     // enclave server to host client
     OE_TEST(thread_create(&thread, enclave_server_thread, (void*)path) == 0);
@@ -217,6 +218,49 @@ static void _run_enclave_server_test(const char* path)
     printf("=== passed %s\n", __FUNCTION__);
 }
 
+static const uint32_t _internal_ipaddr = 0xFF000001;
+
+static void* internal_server_thread(void* arg)
+{
+    int retval;
+    OE_TEST(ecall_run_server(arg, &retval, _internal_ipaddr) == OE_OK);
+    return NULL;
+}
+
+static void _run_internal_server_test(const char* path)
+{
+    oe_enclave_t* enclave = NULL;
+    OE_TEST(
+        oe_create_socket_test_enclave(
+            path,
+            OE_ENCLAVE_TYPE_SGX,
+            oe_get_create_flags(),
+            NULL,
+            0,
+            &enclave) == OE_OK);
+
+    thread_t thread;
+    OE_TEST(thread_create(&thread, internal_server_thread, enclave) == 0);
+
+    // Give the server time to launch
+    sleep_msec(250);
+
+    int ret = 0;
+    char test_data_rtn[1024] = {0};
+    ssize_t test_data_len = 1024;
+    OE_TEST(
+        ecall_run_client(
+            enclave, &ret, _internal_ipaddr, test_data_rtn, &test_data_len) ==
+        OE_OK);
+
+    OE_TEST(ret == OE_OK);
+    printf("host received: %.*s\n", (int)test_data_len, test_data_rtn);
+
+    thread_join(thread);
+    OE_TEST(oe_terminate_enclave(enclave) == OE_OK);
+    printf("=== passed %s\n", __FUNCTION__);
+}
+
 int main(int argc, const char* argv[])
 {
     if (argc != 2)
@@ -232,6 +276,7 @@ int main(int argc, const char* argv[])
 
     _run_host_server_test(argv[1]);
     _run_enclave_server_test(argv[1]);
+    _run_internal_server_test(argv[1]);
 
     sock_cleanup();
 
diff --git a/tests/syscall/socket/socket_test.edl b/tests/syscall/socket/socket_test.edl
index 7767757c0..ade8012ea 100644
--- a/tests/syscall/socket/socket_test.edl
+++ b/tests/syscall/socket/socket_test.edl
@@ -14,8 +14,8 @@ enclave {
 
     trusted {
         /* define ECALLs here. */
-        public int ecall_run_client([in, out, count=1024]char *buf, [in, out, count=1]ssize_t *buflen);
-        public int ecall_run_server();
+        public int ecall_run_client(uint32_t ipaddr, [in, out, count=1024]char *buf, [in, out, count=1]ssize_t *buflen);
+        public int ecall_run_server(uint32_t ipaddr);
     };
 
     untrusted {
diff --git a/tests/tools/oesign/test-enclave/host/host.c b/tests/tools/oesign/test-enclave/host/host.c
index 0878f7b06..9ccb5862c 100644
--- a/tests/tools/oesign/test-enclave/host/host.c
+++ b/tests/tools/oesign/test-enclave/host/host.c
@@ -4,6 +4,7 @@
 #include <openenclave/host.h>
 #include <openenclave/internal/error.h>
 #include <openenclave/internal/load.h>
+#include <openenclave/internal/sgx/tests.h>
 #include <openenclave/internal/tests.h>
 #include <stdio.h>
 #include "../host/sgx/cpuid.h"
@@ -93,7 +94,7 @@ int main(int argc, const char* argv[])
         }
     }
 
-    if (_is_kss_supported())
+    if (_is_kss_supported() && oe_has_sgx_quote_provider())
     {
         result = check_kss_extended_ids(
             enclave,
diff --git a/tools/CMakeLists.txt b/tools/CMakeLists.txt
index 26fc27474..8b12b392f 100644
--- a/tools/CMakeLists.txt
+++ b/tools/CMakeLists.txt
@@ -16,7 +16,9 @@ set(BINARY
 
 ExternalProject_Add(
   oeedger8r-cpp
-  SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR}/oeedger8r-cpp
+  URL ${CMAKE_CURRENT_SOURCE_DIR}/oeedger8r-cpp
+  SOURCE_DIR ${CMAKE_CURRENT_BINARY_DIR}/oeedger8r-cpp-src
+  PATCH_COMMAND patch -p1 < ${ERTSRC}/oeedger8r-cpp.patch
   BINARY_DIR ${CMAKE_CURRENT_BINARY_DIR}/oeedger8r-cpp
   CMAKE_ARGS -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}
   BUILD_ALWAYS on
diff --git a/tools/oesign/main.c b/tools/oesign/main.c
index 450a88271..372ad20c7 100644
--- a/tools/oesign/main.c
+++ b/tools/oesign/main.c
@@ -25,20 +25,25 @@ int oesign(
     const char* x509,
     const char* engine_id,
     const char* engine_load_path,
-    const char* key_id);
+    const char* key_id,
+    const char* payload_path);
 int oedigest(
     const char* enclave,
     const char* conffile,
     const char* digest_file);
+int oesignerid(const char* keyfile);
+int eradump(const char* enc_bin);
 
 static const char _usage_gen[] =
     "Usage: %s <command> [options]\n"
     "\n"
     "Commands:\n"
-    "  sign  -  Sign the specified enclave.\n"
-    "  digest - Create a digest of the specified enclave for signing.\n"
-    "  dump  -  Print out the Open Enclave metadata for the specified "
+    "  sign      -  Sign the specified enclave.\n"
+    "  digest    -  Create a digest of the specified enclave for signing.\n"
+    "  dump      -  Print out the Open Enclave metadata for the specified "
     "enclave.\n"
+    "  signerid  -  Print out the signer ID for the specified public key.\n"
+    "  eradump   -  Generates enclave config in JSON format.\n"
     "\n"
     "For help with a specific command, enter \"%s <command> --help\"\n";
 
@@ -142,6 +147,24 @@ static const char _usage_dump[] =
     "signature information for the specified enclave.\n"
     "\n";
 
+static const char _usage_signerid[] =
+    "Usage: %s signerid -k KEY_FILE\n"
+    "\n"
+    "Options:\n"
+    "  -k, --key-file           path to the public key file of the signer in\n"
+    "                           PEM format.\n"
+    "\n"
+    "Description:\n"
+    "  This option prints the signer ID derived from a public key.\n"
+    "\n";
+
+static const char _usage_eradump[] =
+    "Usage: %s eradump -e ENCLAVE_IMAGE\n"
+    "\n"
+    "Options:\n"
+    "  -e, --enclave-image      path to enclave image file.\n"
+    "\n";
+
 int dump_parser(int argc, const char* argv[])
 {
     int ret = 0;
@@ -289,6 +312,7 @@ int sign_parser(int argc, const char* argv[])
     const char* engine_id = NULL;
     const char* engine_load_path = NULL;
     const char* key_id = NULL;
+    const char* payload_path = NULL;
 
     const struct option long_options[] = {
         {"help", no_argument, NULL, 'h'},
@@ -302,6 +326,7 @@ int sign_parser(int argc, const char* argv[])
         {"load-path", required_argument, NULL, 'p'},
         {"key-id", required_argument, NULL, 'i'},
 #endif
+        {"payload", required_argument, NULL, 0x101},
         {NULL, 0, NULL, 0},
     };
     const char short_options[] = "he:c:k:n:p:i:d:x:";
@@ -356,6 +381,9 @@ int sign_parser(int argc, const char* argv[])
                 key_id = optarg;
                 break;
 #endif
+            case 0x101:
+                payload_path = optarg;
+                break;
             case ':':
                 // Missing option argument
                 ret = 1;
@@ -432,7 +460,8 @@ int sign_parser(int argc, const char* argv[])
             x509,
             engine_id,
             engine_load_path,
-            key_id);
+            key_id,
+            payload_path);
     }
 
 done:
@@ -523,6 +552,122 @@ done:
     return ret;
 }
 
+static int _signerid_parser(int argc, const char* argv[])
+{
+    int ret = 0;
+    const char* keyfile = NULL;
+
+    const struct option long_options[] = {
+        {"help", no_argument, NULL, 'h'},
+        {"key-file", required_argument, NULL, 'k'},
+        {NULL, 0, NULL, 0},
+    };
+    const char short_options[] = "hk:";
+
+    int c;
+    do
+    {
+        c = getopt_long(
+            argc, (char* const*)argv, short_options, long_options, NULL);
+        if (c == -1)
+        {
+            // all the command-line options are parsed
+            break;
+        }
+
+        switch (c)
+        {
+            case 'h':
+                fprintf(stderr, _usage_signerid, argv[0]);
+                goto done;
+            case 'k':
+                keyfile = optarg;
+                break;
+            case ':':
+                // Missing option argument
+                ret = 1;
+                goto done;
+            case '?':
+            default:
+                // Invalid option
+                ret = 1;
+                goto done;
+        }
+    } while (1);
+
+    if (keyfile == NULL)
+    {
+        oe_err("--key-file option is missing");
+        ret = 1;
+    }
+    if (!ret)
+        ret = oesignerid(keyfile);
+
+done:
+
+    return ret;
+}
+
+static int _eradump_parser(int argc, const char* argv[])
+{
+    int ret = 0;
+    const char* enclave = NULL;
+
+    const struct option long_options[] = {
+        {"help", no_argument, NULL, 'h'},
+        {"enclave", required_argument, NULL, 'e'},
+        {NULL, 0, NULL, 0},
+    };
+    const char short_options[] = "he:";
+
+    int c;
+    do
+    {
+        c = getopt_long(
+            argc, (char* const*)argv, short_options, long_options, NULL);
+        if (c == -1)
+        {
+            // all the command-line options are parsed
+            break;
+        }
+
+        switch (c)
+        {
+            case 'h':
+                fprintf(stderr, _usage_eradump, argv[0]);
+                goto done;
+            case 'e':
+                enclave = optarg;
+                break;
+            case ':':
+                // Missing option argument
+                ret = 1;
+                goto done;
+            case '?':
+            default:
+                // Invalid option
+                ret = 1;
+                goto done;
+        }
+    } while (1);
+
+    if (enclave == NULL)
+    {
+        oe_err("--enclave-image option is missing");
+
+        fprintf(stderr, _usage_eradump, argv[0]);
+        ret = 1;
+    }
+
+    if (!ret)
+    {
+        ret = eradump(enclave);
+    }
+
+done:
+    return ret;
+}
+
 int arg_handler(int argc, const char* argv[])
 {
     int ret = 1;
@@ -536,6 +681,10 @@ int arg_handler(int argc, const char* argv[])
         ret = sign_parser(argc, argv);
     else if ((strcmp(argv[1], "digest") == 0))
         ret = digest_parser(argc, argv);
+    else if (strcmp(argv[1], "signerid") == 0)
+        ret = _signerid_parser(argc, argv);
+    else if (strcmp(argv[1], "eradump") == 0)
+        ret = _eradump_parser(argc, argv);
     else
     {
         fprintf(stderr, _usage_gen, argv[0], argv[0]);
diff --git a/tools/oesign/oeinfo.c b/tools/oesign/oeinfo.c
index bddf5c8aa..456d6fbd8 100644
--- a/tools/oesign/oeinfo.c
+++ b/tools/oesign/oeinfo.c
@@ -53,7 +53,8 @@ static char* _make_signed_lib_name(const char* path)
 
 oe_result_t oe_write_oeinfo_sgx(
     const char* path,
-    const oe_sgx_enclave_properties_t* properties)
+    const oe_sgx_enclave_properties_t* properties,
+    bool overwrite)
 {
     oe_result_t result = OE_FAILURE;
     oe_enclave_image_t oeimage;
@@ -74,7 +75,10 @@ oe_result_t oe_write_oeinfo_sgx(
 
     /* Write new signed executable */
     {
-        char* p = _make_signed_lib_name(path);
+        char* signed_name = _make_signed_lib_name(path);
+        const char* p = signed_name;
+        if (overwrite)
+            p = path;
 
         if (!p)
         {
@@ -104,7 +108,7 @@ oe_result_t oe_write_oeinfo_sgx(
 
         printf("Created %s\n", p);
 
-        free(p);
+        free(signed_name);
     }
 
     result = OE_OK;
diff --git a/tools/oesign/oeinfo.h b/tools/oesign/oeinfo.h
index 857ee354e..136063c01 100644
--- a/tools/oesign/oeinfo.h
+++ b/tools/oesign/oeinfo.h
@@ -9,4 +9,5 @@ oe_result_t oe_read_oeinfo_sgx(
 
 oe_result_t oe_write_oeinfo_sgx(
     const char* path,
-    const oe_sgx_enclave_properties_t* properties);
+    const oe_sgx_enclave_properties_t* properties,
+    bool overwrite);
diff --git a/tools/oesign/oesign.c b/tools/oesign/oesign.c
index cbfe236ba..f4b6939d4 100644
--- a/tools/oesign/oesign.c
+++ b/tools/oesign/oesign.c
@@ -399,7 +399,7 @@ done:
     return rc;
 }
 
-static int _load_pem_file(const char* path, void** data, size_t* size)
+int load_pem_file(const char* path, void** data, size_t* size)
 {
     int err = _load_file(path, data, size);
     if (err == 0)
@@ -528,7 +528,8 @@ done:
 oe_result_t _get_sgx_enclave_hash(
     const char* enclave,
     const oe_sgx_enclave_properties_t* properties,
-    OE_SHA256* hash)
+    OE_SHA256* hash,
+    const char* payload_path)
 {
     oe_result_t result = OE_UNEXPECTED;
     oe_enclave_t enc;
@@ -544,7 +545,7 @@ oe_result_t _get_sgx_enclave_hash(
 
     /* Build an enclave to obtain the MRENCLAVE measurement */
     OE_CHECK_ERR(
-        oe_sgx_build_enclave(&context, enclave, properties, &enc),
+        oe_sgx_build_enclave(&context, enclave, properties, &enc, payload_path),
         "oe_sgx_build_enclave(): result=%s (%#x)",
         oe_result_str(result),
         result);
@@ -600,7 +601,8 @@ int oesign(
     const char* x509,
     const char* engine_id,
     const char* engine_load_path,
-    const char* key_id)
+    const char* key_id,
+    const char* payload_path)
 {
     int ret = 1;
     oe_result_t result = OE_UNEXPECTED;
@@ -614,7 +616,8 @@ int oesign(
     OE_CHECK_NO_TRACE(
         _initialize_enclave_properties(enclave, conffile, &properties));
 
-    OE_CHECK_NO_TRACE(_get_sgx_enclave_hash(enclave, &properties, &hash));
+    OE_CHECK_NO_TRACE(
+        _get_sgx_enclave_hash(enclave, &properties, &hash, payload_path));
 
     if (engine_id)
     {
@@ -638,7 +641,7 @@ int oesign(
     else if (digest_signature)
     {
         /* Load the public key from the x509 certificate */
-        if (_load_pem_file(x509, &pem_data, &pem_size) != 0)
+        if (load_pem_file(x509, &pem_data, &pem_size) != 0)
         {
             oe_err("Failed to load file: %s", x509 ? x509 : "NULL");
             goto done;
@@ -688,7 +691,7 @@ int oesign(
     else
     {
         /* Load private key into memory */
-        if (_load_pem_file(keyfile, &pem_data, &pem_size) != 0)
+        if (load_pem_file(keyfile, &pem_data, &pem_size) != 0)
         {
             oe_err("Failed to load file: %s", keyfile ? keyfile : "NULL");
             goto done;
@@ -713,7 +716,10 @@ int oesign(
 
     /* Create signature section and write out new file */
     OE_CHECK_ERR(
-        oe_write_oeinfo_sgx(enclave, &properties),
+        oe_write_oeinfo_sgx(
+            payload_path ? payload_path : enclave,
+            &properties,
+            payload_path ? true : false),
         "oe_write_oeinfo_sgx(): result=%s (%#x)",
         oe_result_str(result),
         result);
@@ -741,7 +747,8 @@ int oedigest(const char* enclave, const char* conffile, const char* digest_file)
     OE_CHECK_NO_TRACE(
         _initialize_enclave_properties(enclave, conffile, &properties));
 
-    OE_CHECK_NO_TRACE(_get_sgx_enclave_hash(enclave, &properties, &mrenclave));
+    OE_CHECK_NO_TRACE(
+        _get_sgx_enclave_hash(enclave, &properties, &mrenclave, NULL));
 
     /* Construct the unsigned sigstruct with the MRENCLAVE and get its digest */
     OE_CHECK_ERR(
